
---

Beginner Level Questions

1. What is the Stream API in Java?

Expectation: You should mention it's a feature in Java 8 for processing collections in a functional style.



2. How is a Stream different from a Collection?

Tip: Mention laziness, immutability, and single-use nature of streams.



3. How do you create a Stream in Java?

Follow-up: From arrays, lists, or with Stream.of().



4. What is the difference between map() and forEach()?

Key Point: map() transforms, forEach() performs action (usually terminal).



5. What are intermediate and terminal operations in streams?

Answer: Intermediate returns a Stream (e.g., map, filter), terminal produces a result (collect, forEach, reduce).



6. Can you explain filter() with an example?


7. What does collect(Collectors.toList()) do?




---

Intermediate Level Questions

8. What is the difference between map() and flatMap()?

Good example: List<List<String>> to List<String> using flatMap().



9. What does distinct() do and how does it work internally?


10. What is the use of sorted()? How to sort a custom object list by a field?



Tip: Use .sorted(Comparator.comparing(Class::getField))


11. Explain limit() and skip() in streams.


12. What is peek() in Stream API and when should it be used?



Important: For debugging, not transformation.


13. Difference between findFirst() and findAny()?



Note: Emphasize behavior in parallel streams.


14. How does anyMatch(), allMatch() and noneMatch() work? Give use cases.


15. What is the use of reduce() in streams?



Follow-up: Can you use reduce() to calculate sum or factorial?



---

Advanced Level Questions

16. What are the advantages of using Stream API over loops?


17. How do streams achieve laziness in execution?



Tip: Mention short-circuiting and internal pipeline structure.


18. What are the performance considerations of using streams?



Bonus: Talk about overhead of autoboxing and when to prefer for loop.


19. When should you use parallel streams? Any risks involved?



Answer: Only with large data and stateless operations. Be cautious of thread-safety and shared mutable state.


20. Explain grouping data using Collectors.groupingBy().



Example: Group a list of employees by department.


21. How would you count duplicate elements using streams?


22. What is a custom collector? Can you write one?


23. What are short-circuiting operations in streams?



E.g. limit(), findFirst(), anyMatch().


24. Can you create an infinite stream? How do you control it?



Example:


Stream.iterate(1, n -> n + 1).limit(10).forEach(System.out::println);

25. Can streams be reused? If not, how do you process a stream twice?



Answer: No, they are single-use. Use Supplier<Stream<T>> for reuse.



---
---

Beginner Level

1. What is Stream API?

Streams in Java are a way to process collections (like List, Set) in a functional and declarative way. Stream operations are lazy, meaning computation is only performed when needed.


---

2. Creating a Stream

From a Collection:

List<String> names = List.of("John", "Jane", "Jack");
Stream<String> stream = names.stream();

From Arrays:

String[] array = {"A", "B", "C"};
Stream<String> stream = Arrays.stream(array);


---

3. forEach() – Terminal operation

Used to iterate over elements of a stream.

names.stream().forEach(name -> System.out.println(name));

Note: forEach should be used for side effects like logging, not for transformation.


---

4. map() – Transform elements

map() is used to transform each element using a function.

List<Integer> numbers = List.of(1, 2, 3, 4);
List<Integer> squares = numbers.stream()
                               .map(n -> n * n)
                               .collect(Collectors.toList());


---

5. filter() – Select elements based on condition

Returns a stream with elements that match a given predicate.

List<String> filtered = names.stream()
                             .filter(name -> name.startsWith("J"))
                             .collect(Collectors.toList());


---

6. collect() – Terminal operation

Collects the stream elements into a Collection, List, Set, or even a Map.

List<String> upper = names.stream()
                          .map(String::toUpperCase)
                          .collect(Collectors.toList());


---

Intermediate Level

7. sorted() – Sorting elements

By default, it sorts based on natural order. You can also provide a comparator.

List<String> sorted = names.stream()
                           .sorted()
                           .collect(Collectors.toList());

List<String> customSorted = names.stream()
                                 .sorted(Comparator.reverseOrder())
                                 .collect(Collectors.toList());


---

8. distinct() – Removing duplicates

List<Integer> numbers = List.of(1, 2, 2, 3, 4, 4);
List<Integer> distinct = numbers.stream()
                                .distinct()
                                .collect(Collectors.toList());


---

9. limit() and skip()

limit(n): Gets the first n elements.

skip(n): Skips the first n elements.


numbers.stream().limit(3).forEach(System.out::println);  // 1 2 3
numbers.stream().skip(2).forEach(System.out::println);   // 3 4


---

10. count() – Counting elements

long count = numbers.stream().filter(n -> n % 2 == 0).count();


---

11. anyMatch(), allMatch(), noneMatch()

anyMatch: true if any element matches.

allMatch: true if all elements match.

noneMatch: true if no element matches.


boolean anyEven = numbers.stream().anyMatch(n -> n % 2 == 0);
boolean allPositive = numbers.stream().allMatch(n -> n > 0);
boolean noneNegative = numbers.stream().noneMatch(n -> n < 0);


---

12. findFirst() and findAny()

Returns an Optional describing the element.

findFirst() gives the first element (useful in ordered streams).

findAny() may return any element (faster with parallel streams).


Optional<Integer> first = numbers.stream().findFirst();
Optional<Integer> any = numbers.stream().findAny();


---

Advanced Level

13. flatMap() – Flatten nested streams

Used when you have nested structures like List<List<T>> and you want a single List<T>.

List<List<String>> nested = List.of(List.of("A", "B"), List.of("C", "D"));

List<String> flat = nested.stream()
                          .flatMap(List::stream)
                          .collect(Collectors.toList());


---

14. reduce() – Aggregating values

reduce() is used for combining elements, like summing or finding max/min.

int sum = numbers.stream().reduce(0, Integer::sum);

String concatenated = names.stream().reduce("", (a, b) -> a + b);


---

15. Collectors.groupingBy() – Group elements by key

Useful for classification/grouping.

List<String> items = List.of("apple", "banana", "apple", "orange", "banana");

Map<String, Long> frequencyMap = items.stream()
                                      .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));


---

16. Parallel Streams – For multi-core processing

Parallelizes stream operations.

List<Integer> bigList = IntStream.range(1, 1000).boxed().collect(Collectors.toList());

bigList.parallelStream()
       .forEach(System.out::println);

Note: Parallel streams are not always faster. Test before using in production.


---

17. Custom Collector – Define how to collect results

Collector<String, ?, String> toUpperJoined =
    Collector.of(
        StringBuilder::new,
        (sb, s) -> sb.append(s.toUpperCase()),
        StringBuilder::append,
        StringBuilder::toString
    );

String result = List.of("a", "b", "c").stream().collect(toUpperJoined);  // "ABC"


---

18. peek() – For debugging stream pipeline

Used to inspect elements during the stream processing.

List<String> debug = names.stream()
                          .peek(name -> System.out.println("Before: " + name))
                          .map(String::toUpperCase)
                          .peek(name -> System.out.println("After: " + name))
                          .collect(Collectors.toList());


---
---

Basic Coding Questions

1. Convert a list of strings to uppercase

List<String> input = List.of("a", "b", "c");
List<String> result = input.stream()
                           .map(String::toUpperCase)
                           .collect(Collectors.toList());


---

2. Find even numbers from a list

List<Integer> nums = List.of(1, 2, 3, 4, 5);
List<Integer> evens = nums.stream()
                          .filter(n -> n % 2 == 0)
                          .collect(Collectors.toList());


---

3. Count strings starting with "A"

List<String> names = List.of("Adam", "Alex", "Brian");
long count = names.stream()
                  .filter(name -> name.startsWith("A"))
                  .count();


---

Intermediate Coding Questions

4. Find duplicate elements in a list

List<String> list = List.of("apple", "banana", "apple", "orange", "banana");

Set<String> seen = new HashSet<>();
Set<String> duplicates = list.stream()
                             .filter(e -> !seen.add(e))
                             .collect(Collectors.toSet());


---

5. Group strings by their length

List<String> words = List.of("hi", "hello", "yes", "no", "java");

Map<Integer, List<String>> grouped = words.stream()
                                          .collect(Collectors.groupingBy(String::length));


---

6. Sort a list of strings in reverse order

List<String> sorted = words.stream()
                           .sorted(Comparator.reverseOrder())
                           .collect(Collectors.toList());


---

7. Join strings with a comma

String joined = words.stream()
                     .collect(Collectors.joining(", "));


---

8. Sum of all even numbers using reduce()

int sum = nums.stream()
              .filter(n -> n % 2 == 0)
              .reduce(0, Integer::sum);


---

Advanced Coding Questions

9. Find the first non-repeating character in a string

String input = "swiss";

Character result = input.chars()
                        .mapToObj(c -> (char) c)
                        .filter(c -> input.indexOf(c) == input.lastIndexOf(c))
                        .findFirst()
                        .orElse(null);


---

10. Group and count word frequency

List<String> words = List.of("apple", "banana", "apple", "apple", "banana");

Map<String, Long> frequency = words.stream()
                                   .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));


---

11. Flatten a list of lists

List<List<Integer>> nested = List.of(List.of(1, 2), List.of(3, 4));

List<Integer> flat = nested.stream()
                           .flatMap(List::stream)
                           .collect(Collectors.toList());


---

12. Partition numbers into even and odd

Map<Boolean, List<Integer>> partitioned = nums.stream()
                                              .collect(Collectors.partitioningBy(n -> n % 2 == 0));


---

13. Get top 3 highest numbers

List<Integer> top3 = nums.stream()
                         .sorted(Comparator.reverseOrder())
                         .limit(3)
                         .collect(Collectors.toList());


---

14. Custom object grouping: Group employees by department

Map<String, List<Employee>> byDept = employees.stream()
                                              .collect(Collectors.groupingBy(Employee::getDepartment));


---
