100+ Spring Boot Questions 1
100+ Spring Boot Questions
1. Explain the concept of "convention over configuration" in Spring Boot: 
The concept of "convention over configuration" in Spring Boot emphasizes the 
idea that developers can benefit from default configurations and sensible 
assumptions, reducing the need for explicit configuration. It follows a set of 
predefined conventions and rules to simplify the development process. By 
following these conventions, developers can rapidly create applications with 
minimal configuration, reducing the amount of boilerplate code required. Spring 
Boot provides sensible defaults and makes intelligent choices based on common 
use cases and best practices, allowing developers to focus more on writing 
business logic rather than dealing with intricate setup and configuration details.
2. What is the difference between Spring and Spring Boot? 
Spring is a powerful Java framework that provides a comprehensive set of 
features for developing enterprise-grade applications. It covers a wide range of 
modules and libraries, including Spring Core, Spring MVC, Spring Security, 
Spring Data, and more. Spring requires explicit configuration and setup to wire 
components and manage dependencies.
Spring Boot, on the other hand, is a sub-project of the Spring Framework that 
aims to simplify the development process by providing opinionated defaults and 
auto-configuration. It leverages the capabilities of the Spring Framework while 
minimizing the need for explicit configuration. Spring Boot focuses on convention 
over configuration and provides a streamlined approach to building stand-alone, 
production-grade Spring applications.
100+ Spring Boot Questions 2
3. How does Spring Boot simplify the development of Java applications? 
Spring Boot simplifies Java application development in several ways:
It provides auto-configuration, where common components and 
dependencies are automatically configured based on classpath scanning 
and sensible defaults.
Spring Boot offers a curated set of starter dependencies that include all the 
necessary libraries for specific functionalities, reducing the effort of 
managing dependencies manually.
It comes with an embedded server, such as Tomcat, Jetty, or Undertow, 
allowing developers to run applications as standalone JAR files without 
requiring a separate web server installation.
Spring Boot Actuator provides production-ready features out of the box, such 
as health checks, metrics, and monitoring capabilities.
It offers a range of developer tools, including automatic restart, live reload, 
and a command-line interface (CLI), enhancing productivity during the 
development process.
4. What are the various ways to create a Spring Boot application? 
There are several ways to create a Spring Boot application:
Using the Spring Initializr: The Spring Initializr is a web-based tool that 
generates a project structure and initializes a Spring Boot application with 
the desired dependencies. It allows customization of project metadata, 
dependencies, and packaging options.
Using Spring Boot CLI: The Spring Boot CLI (Command-Line Interface) 
allows developers to create and run Spring Boot applications directly from 
the command line. It provides a convenient way to prototype and develop 
Spring Boot applications quickly.
Manually creating a project structure: Developers can manually create the 
project structure by setting up the necessary directories and configuration 
files. They can then add the required dependencies and configure the build 
system (e.g., Maven or Gradle) to manage the project.
5. What is the role of the @SpringBootApplication  annotation? 
The @SpringBootApplication  annotation is a convenience annotation in Spring 
Boot that combines three essential annotations: @Configuration , 
@EnableAutoConfiguration , and @ComponentScan . It is typically used to annotate the 
100+ Spring Boot Questions 3
main class of a Spring Boot application. This single annotation enables auto-
configuration, component scanning, and application context setup, making it a 
powerful shortcut for configuring Spring Boot applications.
6. Explain the concept of auto-configuration in Spring Boot: 
Auto-configuration in Spring Boot is a key feature that eliminates much of the 
manual configuration effort required when building Spring applications. It 
leverages classpath scanning and
conditional configuration to automatically configure beans and set up sensible 
defaults based on the dependencies present in the project.
Spring Boot auto-configuration works by analyzing the classpath and 
determining which beans should be created and configured based on the 
available libraries and dependencies. It uses the @Conditional  annotations to 
conditionally enable or disable specific configurations based on the presence or 
absence of certain classes, properties, or conditions.
Auto-configuration provides a significant advantage in Spring Boot as it reduces 
the need for developers to explicitly configure every component of the 
application. It simplifies the development process by automatically configuring 
commonly used components such as data sources, JPA providers, web 
frameworks, security, and more, based on sensible defaults and conventions.
7. How does Spring Boot handle dependency management? 
Spring Boot simplifies dependency management by providing a curated set of 
starter dependencies. These starter dependencies are opinionated, pre-
configured dependencies that include all the necessary libraries and 
configurations for specific functionalities or technologies. By including a starter 
dependency, developers can easily leverage the features and capabilities 
provided by that technology without worrying about manually managing the 
dependencies.
Spring Boot manages dependencies through its dependency management 
plugin, which ensures that all dependencies within a specific version range are 
compatible with each other. Developers can simply declare the starters they 
need in their project's build configuration (e.g., Maven or Gradle), and Spring 
Boot will resolve and manage the transitive dependencies automatically.
8. What is the purpose of the application.properties  or application.yml  file? 
The application.properties  or application.yml  file is used in Spring Boot for 
externalized configuration. It provides a convenient way to configure various 
properties of the application without modifying the source code. These properties 
100+ Spring Boot Questions 4
include database connection details, server port, logging configuration, 
application-specific settings, and more.
The application.properties  file uses a key-value format, while application.yml  
uses YAML (YAML Ain't Markup Language) format. Both formats allow 
developers to specify configuration properties and their corresponding values.
Spring Boot automatically loads and applies the properties defined in these files 
during application startup. It provides sensible default values, and developers 
can override these defaults by specifying the properties in the 
application.properties  or application.yml  file.
9. How can you override the default properties in Spring Boot? 
To override default properties in Spring Boot, you can provide custom values in 
the application.properties  or application.yml  file. By specifying the properties in 
these files, Spring Boot will use the custom values instead of the default values.
When defining custom properties, you need to use the same property keys as 
the ones used in the default configuration. By setting a property with the same 
key in the custom configuration file, Spring Boot will override the default value 
with the custom value.
Additionally, you can also override properties using command-line arguments or 
environment variables. By providing a command-line argument or setting an 
environment variable with the same key as a property, you can override the 
default value during application startup.
The precedence order for property resolution in Spring Boot is: command-line 
arguments or environment variables > application.properties  or application.yml  
> default values.
10. What is the purpose of the @Autowired  annotation in Spring Boot? 
The @Autowired  annotation in Spring Boot is used for automatic dependency 
injection. It allows Spring to automatically wire and inject dependencies into a 
class or a bean without the need for manual configuration.
By using @Autowired , you can declare a dependency within a class, and Spring 
will resolve and provide the appropriate instance of that dependency at runtime. 
It enables loose coupling and promotes the use of interfaces, making the code 
more maintainable and testable.
The @Autowired  annotation can be used with constructor injection, setter 
injection, or field injection, depending on the preference and design of the 
100+ Spring Boot Questions 5
application. When applied, Spring Boot will scan the classpath for suitable 
dependencies and inject them accordingly.
11. Explain the concept of profiles in Spring Boot. 
Profiles in Spring Boot allow you to define different sets of configurations based 
on the environment or application context. A profile represents a specific 
configuration or behavior that can be activated selectively based on specific 
conditions.
Profiles are useful when you want to have different configurations for different 
environments, such as development, testing, or production. It allows you to 
define property values, beans, or other components specific to a particular 
profile. For example, you may have a database connection configuration specific 
to the development profile and another configuration for the production profile.
By utilizing profiles, you can easily switch between different configurations 
without modifying the codebase, making your application more flexible and 
adaptable to different environments.
12. How can you enable a specific profile in Spring Boot? 
To enable a specific profile in Spring Boot, you can set the spring.profiles.active  
property in the application.properties  or application.yml  file. You can specify the 
active profile(s) as a comma-separated list.
For example, to activate the "development" profile, you can set 
spring.profiles.active=development  in the configuration file. If you want to activate 
multiple profiles, separate them with commas like 
spring.profiles.active=development,production .
Additionally, you can also set the active profiles using command-line arguments 
or environment variables. For example, you can use the --
spring.profiles.active=development  command-line argument or set the 
SPRING_PROFILES_ACTIVE  environment variable to development  to activate the 
"development" profile.
Spring Boot will then load the corresponding configuration properties and beans 
specific to the active profile(s) during application startup.
13. How does Spring Boot support the creation of RESTful web services? 
Spring Boot provides comprehensive support for building RESTful web services. 
It integrates the Spring MVC framework, which is widely used for building web 
applications, and simplifies the process of creating RESTful APIs.
To create RESTful web services in Spring Boot, you can follow these steps:
100+ Spring Boot Questions 6
1. Annotate your controller class with @RestController  to indicate that it will 
handle RESTful requests and automatically serialize responses as JSON or 
XML.
2. Use @RequestMapping  or other specialized annotations like @GetMapping , 
@PostMapping , etc., to map HTTP requests to specific controller methods.
3. Define the necessary request parameters, path variables, and headers using 
annotations like @RequestParam , @PathVariable , @RequestHeader , etc.
4. Return the appropriate HTTP response using ResponseEntity , @ResponseBody , 
or specific response-related annotations.
5. Optionally, handle exceptions using @ExceptionHandler  to provide custom 
error handling and appropriate HTTP responses for exceptional cases.
Spring Boot also offers features like content negotiation, request validation, input 
conversion, and automatic documentation generation through libraries like 
Spring HATEOAS and Springfox Swagger, which further enhance the 
development of
RESTful web services.
14. What is Spring Data JPA, and how does it integrate with Spring Boot? 
Spring Data JPA is a sub-project of Spring Data that provides an abstraction 
layer on top of JPA (Java Persistence API) for simplified database access in 
Java applications. It reduces the amount of boilerplate code required for 
database interactions and enables developers to work with persistent data using 
a high-level, object-oriented approach.
Spring Data JPA integrates seamlessly with Spring Boot, leveraging its auto-
configuration and convention-over-configuration principles. With minimal 
configuration, Spring Boot automatically sets up a JPA data source, transaction 
management, and entity manager factory.
To use Spring Data JPA in a Spring Boot application, you typically need to 
perform the following steps:
1. Define JPA entities or domain objects representing database tables or 
documents.
2. Create repositories by extending the appropriate Spring Data JPA interfaces 
(e.g., CrudRepository , JpaRepository ), which provide out-of-the-box CRUD 
operations and querying capabilities.
100+ Spring Boot Questions 7
3. Use these repositories in your application to perform database operations, 
eliminating the need for manually writing SQL queries and JDBC code.
4. Configure the data source properties and JPA settings in the 
application.properties  or application.yml  file.
Spring Boot takes care of setting up the necessary components, such as the 
entity manager, transaction manager, and database connection, based on the 
default configuration and conventions.
15. Explain the role of Spring Security in Spring Boot applications. 
Spring Security is a powerful security framework that provides authentication, 
authorization, and other security features for Java applications. It allows you to 
secure your Spring Boot applications and protect resources from unauthorized 
access.
In a Spring Boot application, Spring Security can be easily integrated and 
configured using various annotations and configurations. Some key aspects of 
Spring Security in Spring Boot include:
Authentication: Spring Security provides various authentication 
mechanisms, including form-based authentication, OAuth, JWT, and more. It 
allows you to define user authentication and verification logic, such as 
connecting to a database, LDAP, or custom authentication providers.
Authorization: Spring Security enables you to define fine-grained access 
control and authorization rules using expressions, annotations, or 
configuration. You can secure specific URLs, RESTful endpoints, or 
methods based on user roles, permissions, or other criteria.
Security Filters: Spring Security utilizes a set of filters that intercept 
requests and perform security-related operations, such as authentication, 
authorization, and session management.
Integration with Web Frameworks: Spring Security integrates seamlessly 
with Spring MVC and Spring Boot, providing out-of-the-box security 
configurations and user interfaces for login and logout.
By incorporating Spring Security into a Spring Boot application, you can enforce 
secure access control, protect sensitive resources, and implement robust 
authentication and authorization mechanisms.
16. How can you enable logging in a Spring Boot application? 
Spring Boot provides built-in support for logging using the widely-used logging 
100+ Spring Boot Questions 8
frameworks, such as Logback, Log4j2, and Java Util Logging (JUL). By default, 
Spring Boot uses Logback as the logging implementation.
To enable logging in a Spring Boot application, you can follow these steps:
1. Add the appropriate logging framework dependency to your project's build 
configuration (e.g., Maven or Gradle). Spring Boot's starters often include 
the necessary logging dependencies, so you may not need to add them 
explicitly.
2. Configure the logging properties in the application.properties  or 
application.yml  file. For example, you can specify the logging level, log file 
location, log patterns, etc.
3. Use logging statements in your code using the appropriate logger provided 
by the logging framework. For example, you can use SLF4J API with 
Logback implementation.
4. During runtime, the logging framework will handle the logging statements 
based on the configuration. The logs can be outputted to the console, written 
to log files, or sent to external log management systems.
Spring Boot's logging configuration provides flexibility to customize and 
configure various aspects of logging, allowing you to control log levels, log 
output formats, log rotation, and more. 
17. What is the purpose of the @RestController  annotation? 
The @RestController  annotation is used in Spring Boot to indicate that a class is a 
specialized version of the @Controller  annotation, specifically for building 
RESTful web services. It combines the @Controller  and @ResponseBody  
annotations into a single, convenient annotation.
When you annotate a class with @RestController , Spring Boot treats all the 
handler methods within that class as being responsible for generating the 
response body for RESTful requests. It eliminates the need to annotate 
individual methods with @ResponseBody  because @RestController  implicitly adds it 
to all the methods.
The @RestController  annotation simplifies the development of RESTful web 
services by eliminating the need to explicitly annotate every method with 
@ResponseBody  and makes it more concise and expressive.
18. How can you handle exceptions in a Spring Boot application? 
In Spring Boot, you can handle exceptions by utilizing the @ExceptionHandler  
100+ Spring Boot Questions 9
annotation and defining exception handling methods within your controllers or 
using global exception handling techniques.
Here's how you can handle exceptions in a Spring Boot application:
Controller-Level Exception Handling: You can annotate a method in your 
controller class with @ExceptionHandler  and specify the exception type that it 
can handle. When that particular exception occurs within the controller's 
methods, the annotated exception handling method will be invoked, allowing 
you to customize the error response or perform specific actions.
Global Exception Handling: Spring Boot allows you to define a global 
exception handler by creating a class annotated with @ControllerAdvice  and 
implementing exception handling methods. These methods can handle 
exceptions thrown from any controller within the application, providing 
centralized and consistent error handling.
In both approaches, you can customize the error response, log the exception 
details, redirect to an error page, or perform any other necessary actions based 
on the specific exception being handled.
19. Explain the difference between @Component , @Service , and @Repository  
annotations in Spring Boot:
In Spring Boot, @Component , @Service , and @Repository  are three stereotype 
annotations used to categorize and define the roles of classes within an 
application.
@Component  is a generic stereotype annotation that indicates a class is a 
component or a bean. It is the base annotation for all other stereotypes. It is 
typically used for classes that don't fall into the specific categories of 
@Service  or @Repository .
@Service  is a specialization of @Component  and represents a service layer 
component. It is typically used to annotate classes that provide business 
logic, perform operations, or coordinate activities within the application. 
Services are often used to encapsulate complex operations and make them 
available to other parts of the application.
@Repository  is also a specialization of @Component  and represents a repository 
or data access component. It is commonly used for classes that interact with 
the database or any other data storage mechanism. Repositories typically 
100+ Spring Boot Questions 10
provide CRUD (Create, Read, Update, Delete) operations for accessing and 
managing persistent data.
The main difference between these annotations lies in their intended roles and 
responsibilities. While all three are essentially used to define Spring beans, 
using the appropriate annotation helps convey the purpose and intent of the 
class to other developers. It also allows for potential optimizations and clarity in 
the codebase.
20. What is the purpose of the @Transactional  annotation in Spring Boot?
The @Transactional  annotation in Spring Boot is used to define the transactional 
behavior of a method or a class. Transactions ensure that a set of operations are 
treated as a single unit of work, providing ACID (Atomicity, Consistency, 
Isolation, Durability) properties.
By annotating a method or class with @Transactional , Spring Boot automatically 
manages the transactional behavior, handling transaction demarcation, 
propagation, and rollback based on the configured settings.
The @Transactional  annotation can be placed at the method level, where it 
defines that the method should be executed within a transactional context. It can 
also be placed at the class level, where all public methods of that class become 
transactional.
The purpose of the @Transactional  annotation is to simplify transaction 
management by providing a declarative way to define the transactional 
boundaries. It allows developers to focus on the business logic without worrying 
about the low-level transaction management details.
21. How does Spring Boot support database migrations?
Spring Boot provides integration with database migration tools such as Flyway 
and Liquibase to handle database schema management and migration.
Database migration tools allow you to define and version database schema 
changes as a series of migrations. These migrations can be executed 
automatically during application startup or manually as part of the deployment 
process.
In Spring Boot, you can use Flyway or Liquibase by including their respective 
dependencies in your project's build configuration. Then, you can define 
database migration scripts in the form of SQL or XML files, specifying the 
changes you want to make to the database schema.
100+ Spring Boot Questions 11
Spring Boot automatically detects these migration scripts and executes them 
against the database during application startup. It ensures that the database 
schema is in sync with the defined migrations, allowing for seamless evolution of 
the database schema as the application evolves.
By supporting database migrations, Spring Boot facilitates a smooth and 
controlled process of managing database schema changes, ensuring 
consistency across different deployment environments.
22. What is the role of Spring Boot Actuator?
Spring Boot Actuator is a powerful feature of Spring Boot that provides 
production-ready management and monitoring capabilities for your applications. 
It offers a set of built-in endpoints and tools for managing and monitoring
application health, metrics, logging, tracing, and more.
The key role of Spring Boot Actuator is to expose valuable insights and control 
over the running application. It allows you to gather real-time information about 
your application's health, performance, and behavior, making it easier to monitor 
and manage the application in production environments.
Spring Boot Actuator provides various endpoints, such as /health , /info , 
/metrics , /env , /loggers , and many more. These endpoints can be accessed 
via HTTP or JMX, providing a wealth of information about the application's 
internals.
Actuator also allows you to customize and extend its functionality by defining 
custom endpoints, health indicators, and metrics collectors. This flexibility 
enables you to tailor the monitoring and management capabilities to fit the 
specific requirements of your application.
Overall, Spring Boot Actuator plays a vital role in ensuring that your Spring Boot 
application is production-ready by providing essential features for monitoring, 
management, and troubleshooting.
23. How can you configure caching in a Spring Boot application?
Spring Boot provides seamless integration with caching frameworks, such as 
Ehcache, Caffeine, Hazelcast, and others, through the @EnableCaching  annotation 
and caching-related annotations.
To configure caching in a Spring Boot application, you can follow these steps:
1. Add the desired caching framework's dependency to your project's build 
configuration (e.g., Maven or Gradle).
100+ Spring Boot Questions 12
2. Annotate the configuration class or main class with @EnableCaching  to enable 
caching support.
3. Use caching-related annotations, such as @Cacheable , @CachePut , and 
@CacheEvict , at the method level to specify caching behavior.
4. Configure the cache properties, such as cache names, cache managers, 
eviction policies, etc., in the application.properties  or application.yml  file.
By leveraging caching annotations, you can cache method results based on the 
specified cache names and cache keys. This allows subsequent invocations of 
the same method with the same inputs to be served from the cache, improving 
performance and reducing redundant computations.
Spring Boot's caching support makes it easy to integrate caching capabilities 
into your application, resulting in improved performance and scalability.
24. Explain the concept of Bean scopes in Spring Boot.
Bean scopes in Spring Boot define the lifecycle and visibility of Spring-managed 
beans. They determine how instances of a particular bean are created, 
managed, and shared within the application context.
Spring Boot provides several bean scopes, including:
Singleton: The default scope. A singleton bean is created only once, and 
the same instance is shared across all requests. It remains in the application 
context until the application shuts down.
Prototype: A new instance of the prototype bean is created each time it is 
requested. It allows multiple instances of the same bean to coexist within the 
application.
Request: A new instance of the request-scoped bean is created for each 
HTTP request. It is useful when you want to store data specific to a single 
request, such as user session information.
Session: A new instance of the session-scoped bean is created for each 
user session. It maintains the state specific to a user's session across 
multiple requests.
Application: A new instance of the application-scoped bean is created once 
for the entire application. It is shared across all requests and sessions.
WebSocket: A new instance of the web socket-scoped bean is created for 
each WebSocket session.
100+ Spring Boot Questions 13
By selecting the appropriate bean scope, you can control the lifecycle and 
visibility of beans, ensuring that they are managed and shared according to your 
application's requirements.
25. *What is the purpose of the `@Value` annotation in Spring Boot?**
The @Value  annotation in Spring Boot is used to inject values from properties 
files, environment variables, command-line arguments, or other sources into 
Spring-managed beans.
By annotating a field, setter method, or constructor parameter with @Value , you 
can specify the placeholder expression to retrieve the value from the configured 
sources.
For example, you can use @Value("${my.property}")  to inject the value of the 
my.property  property defined in the application.properties  or application.yml  file.
The @Value  annotation is versatile and can be used in various scenarios, such 
as injecting simple values, configuring object properties, setting default values, 
or retrieving values from different sources. It allows you to externalize and 
configure properties for your application in a flexible and dynamic manner.
26. How can you enable Cross-Origin Resource Sharing (CORS) in a Spring 
Boot application?
To enable Cross-Origin Resource Sharing (CORS) in a Spring Boot application, 
you can configure CORS-related settings in your application's configuration class
or using properties.
Here are two approaches to enable CORS in a Spring Boot application:
1. Using @CrossOrigin  annotation: You can annotate specific controller 
methods or the entire controller class with the @CrossOrigin  annotation. This 
annotation allows you to specify the allowed origins, methods, headers, and 
other CORS-related configurations. For example:
@CrossOrigin(origins = "<http://example.com>") 
@RestController 
public class MyController { 
    // ... 
} 
1. Using configuration properties: You can configure CORS-related settings 
in the application.properties  or application.yml  file. For example:
100+ Spring Boot Questions 14
# CORS settings 
spring.webflux.cors.allowed-origins=http://example.com 
spring.webflux.cors.allowed-methods=GET,POST 
spring.webflux.cors.allowed-headers=Authorization,Content-Type 
By enabling CORS, you allow cross-origin requests from specified origins, 
methods, and headers, ensuring that your Spring Boot application can be 
accessed by clients from different domains.
27. Explain the concept of a starter dependency in Spring Boot.
In Spring Boot, a starter dependency is a convenient way to include a specific 
set of dependencies and configurations for a particular functionality or 
technology stack. Starters are curated collections of dependencies that provide a 
cohesive set of libraries, configurations, and auto-configuration for a specific use 
case.
By including a starter dependency in your Spring Boot project, you get access to 
all the necessary libraries, configurations, and Spring Boot auto-configuration 
tailored for that particular functionality or technology stack. Starters simplify the 
dependency management process and ensure that the required dependencies 
and configurations are correctly aligned and compatible.
Starters are named using a spring-boot-starter-*  convention, where the *  
represents the specific functionality or technology. For example, spring-boot-
starter-web  includes the necessary dependencies and configurations for building 
web applications.
Starters provide an opinionated and efficient way to bootstrap your Spring Boot 
projects by providing a curated set of dependencies and configurations, reducing 
the need for manual dependency management and configuration setup.
28. What is the purpose of the @Async  annotation in Spring Boot?
The @Async  annotation in Spring Boot is used to indicate that a method should 
be executed asynchronously, in a separate thread, without blocking the calling 
thread.
By annotating a method with @Async , Spring Boot automatically creates a proxy 
for that method and executes it in a separate thread from a thread pool managed 
by Spring's TaskExecutor . This allows the calling thread to continue its execution 
without waiting for the asynchronous method to complete.
100+ Spring Boot Questions 15
The @Async  annotation is often used for time-consuming or non-blocking 
operations, such as sending emails, performing background tasks, executing 
long-running computations, or making remote API calls.
To enable the @Async  annotation, you need to configure a TaskExecutor  bean in 
your application context. Spring Boot provides sensible default configurations, 
but you can customize the thread pool size and other settings as per your 
requirements.
The @Async  annotation enhances the responsiveness and performance of your 
application by allowing concurrent execution of non-blocking tasks, improving 
overall throughput and user experience.
29. How does Spring Boot support the creation of WebSocket applications?
Spring Boot provides built-in support for creating WebSocket applications 
through Spring's WebSocket API and integration with WebSocket libraries such 
as javax.websocket  and
SockJS .
To create WebSocket applications in Spring Boot, you can follow these steps:
1. Include the necessary dependencies in your project's build configuration 
(e.g., Maven or Gradle). Spring Boot's starters often include the required 
dependencies, so you may not need to add them explicitly.
2. Create a WebSocket handler class by implementing the WebSocketHandler  
interface. This class handles WebSocket connection, messages, and 
lifecycle events.
3. Configure WebSocket-related settings in your application's configuration 
class or properties file. For example, you can define the WebSocket 
endpoint and other properties.
4. Annotate the configuration class or main class with @EnableWebSocket  to 
enable WebSocket support in your application.
5. Implement WebSocket endpoints or controllers by annotating them with 
@Controller  and using WebSocket-related annotations such as 
@MessageMapping  to handle incoming WebSocket messages.
By following these steps, you can create WebSocket applications that allow 
bidirectional communication between the client and the server, enabling real-
time data exchange and interaction.
100+ Spring Boot Questions 16
30. Explain the concept of conditional bean registration in Spring Boot.
Conditional bean registration in Spring Boot allows you to conditionally create 
and register beans based on specific conditions, such as the presence of certain 
classes, properties, or other runtime conditions.
Spring Boot provides the @Conditional  annotation and a set of predefined 
condition classes that you can use to specify the conditions for bean registration.
For example, you can use the @ConditionalOnClass  annotation to conditionally 
register a bean only if a specific class is present in the classpath:
@Configuration 
@ConditionalOnClass(DataSource.class) 
public class DataSourceConfiguration { 
    // Bean definitions... 
}
In this example, the DataSourceConfiguration  class is registered as a bean only if the 
DataSource  class is present in the classpath.
Conditional bean registration allows for flexible configuration and customization 
of your Spring Boot application based on the specific runtime conditions. It helps 
ensure that beans are created and registered only when the required 
dependencies or conditions are met.
31. How can you schedule tasks in a Spring Boot application?
In Spring Boot, you can schedule tasks using the @Scheduled  annotation and the 
@EnableScheduling  annotation.
Here's how you can schedule tasks in a Spring Boot application:
1. Annotate the configuration class or main class with @EnableScheduling  to 
enable scheduling support.
2. In the class where you want to schedule a task, annotate the method that 
should be scheduled with the @Scheduled  annotation. This annotation allows 
you to specify the schedule for the task using cron expressions, fixed delays, 
fixed rates, or initial delays.
3. Customize the scheduling behavior as per your requirements. For example, 
you can use cron expressions to define complex schedules, set fixed delay 
or rate durations, or configure initial delays.
100+ Spring Boot Questions 17
The Spring Boot scheduler executes the annotated method according to the 
specified schedule. It runs the task in a separate thread managed by Spring's 
TaskScheduler .
Scheduling tasks in a Spring Boot application allows you to automate repetitive 
or time-based tasks, such as generating reports, sending notifications, or 
performing periodic data updates.
32. What is the purpose of the @RequestMapping  annotation?
The @RequestMapping  annotation in Spring Boot is used to map HTTP requests to 
specific handler methods in a controller class.
By annotating a method or a controller class with @RequestMapping , you define the 
URL path or paths that the method or class should handle. Additionally, you can 
specify HTTP methods, request headers, request parameters, and other 
conditions to further refine the mapping.
For example, to map a method to handle GET requests at the path /hello , you 
can use the following code:
@Controller 
public class MyController { 
    @RequestMapping(value = "/hello", method = RequestMethod.GET) 
    public String hello() { 
        return "Hello, world!"; 
    } 
} 
The @RequestMapping  annotation provides a powerful way to handle different types of 
requests and route them to the appropriate methods in your controllers. It allows you 
to build RESTful APIs and web applications by defining the mapping between URLs 
and the corresponding controller logic.
33. How can you enable HTTPS in a Spring Boot application?
To enable HTTPS in a Spring Boot application, you need to configure an 
SSL/TLS certificate and update the application's configuration.
Here are the steps to enable HTTPS in a Spring Boot application:
1. Obtain or generate an SSL/TLS certificate for your domain. This can be 
done through a trusted certificate authority or by creating a self-signed 
certificate.
100+ Spring Boot Questions 18
2. Store the certificate and private key in a keystore file, typically in PKCS12 
format.
3. Update the application's configuration in the application.properties  or 
application.yml  file to enable HTTPS. Set the following properties:
server.port=8443 
server.ssl.key-store-type=PKCS12 
server.ssl.key-store=classpath:keystore.p12 
server.ssl.key-store-password=your-password 
In this example, the server will listen on port 8443 and use the specified keystore 
file with the provided password.
4. Restart the application, and it will now be accessible over HTTPS.
Enabling HTTPS in a Spring Boot application ensures secure communication 
between the server and clients by encrypting the data transmitted over the 
network. It is particularly important when dealing with sensitive information, such 
as user credentials or financial data.
34. Explain the concept of externalized configuration in Spring Boot.
Externalized configuration in Spring Boot refers to the practice of storing 
application configuration settings outside of the application code. Instead of 
hardcoding configuration values, Spring Boot allows you to configure and 
customize various aspects of the application through external configuration files, 
environment variables, command-line arguments, or other external sources.
The main benefits of externalized configuration are:
Flexibility: By externalizing configuration, you can modify application 
behavior without modifying the source code. It enables you to adjust settings 
based on different environments (development, testing, production) or 
dynamically change configurations at runtime.
Separation of Concerns: Externalized configuration separates the 
configuration concerns from the application logic. It allows developers to 
focus on writing code without worrying about specific configuration values.
Secure Configuration: Sensitive information, such as database credentials 
or API keys, can be stored securely in external configuration files or 
environment variables, keeping them separate from the codebase.
100+ Spring Boot Questions 19
In Spring Boot, the most common external configuration sources are 
application.properties  or application.yml  files, which are typically located in 
the classpath. Additionally, Spring Boot supports other configuration file 
formats and offers a hierarchy of property sources, allowing properties to be 
overridden or inherited from different sources.
35. What is the purpose of the @RestControllerAdvice  annotation?
The @RestControllerAdvice  annotation in Spring Boot combines the functionalities 
of @ControllerAdvice  and @ResponseBody  annotations. It is used to handle 
exceptions and provide global, centralized exception handling for RESTful APIs.
When you annotate a class with @RestControllerAdvice , it becomes a specialized 
version of @ControllerAdvice , specifically for RESTful APIs. It allows you to define 
exception handling methods that are applied globally to all @RestController  or 
@RequestMapping  annotated classes in your application.
Exception handling methods within a @RestControllerAdvice  class can return 
custom error responses, handle specific exceptions, perform logging, or execute 
any necessary actions when an exception occurs during API request processing.
The @RestControllerAdvice  annotation simplifies the process of handling 
exceptions in RESTful APIs by providing a centralized mechanism for consistent 
error handling and response generation.
36. How does Spring Boot support testing of applications?
Spring Boot provides comprehensive support for testing applications through its 
testing framework and integration with popular testing libraries, such as JUnit 
and Mockito.
Spring Boot testing features include:
Test Annotations: Spring Boot provides annotations such as 
@SpringBootTest , @WebMvcTest , and @DataJpaTest  that allow you to set up a test 
environment and configure specific slices of the application for testing.
Auto-configuration: During testing, Spring Boot automatically configures 
the application context based on the dependencies and configurations 
defined in the test classpath. It creates an isolated environment that mimics 
the behavior of the actual application.
Mocking and Stubbing: Spring Boot integrates with mocking libraries like 
Mockito, allowing you to create mock objects and stub dependencies for unit 
100+ Spring Boot Questions 20
testing. You can use @MockBean  to mock Spring beans and @Autowired  to 
inject the mock objects.
Embedded Servers: Spring Boot provides embedded servers, such as 
Tomcat or Jetty, that can be used during integration testing. These servers 
allow you to perform end-to-end testing of your application's RESTful 
endpoints or web components.
Testing Utilities: Spring Boot offers testing utilities and helper classes that 
facilitate testing, such as TestRestTemplate  for testing RESTful APIs, 
TestEntityManager  for testing JPA entities, and MockMvc  for testing MVC 
controllers.
With these testing features, Spring Boot simplifies the testing process, allows for 
various types of testing (unit, integration, end-to-end), and provides a robust 
framework for writing comprehensive tests for your applications.
35. Explain the concept of cross-cutting concerns in Spring Boot.
In software development, cross-cutting concerns refer to functionalities or 
requirements that are common and span across different modules or 
components of an application. These concerns typically cut across the core 
functionality of the application and affect multiple parts of the codebase.
Some common cross-cutting concerns include logging, security, transaction 
management, caching, error handling, and validation. These concerns often 
involve repetitive and boilerplate code that needs to be implemented consistently 
throughout the application.
Spring Boot addresses cross-cutting concerns through various mechanisms:
Aspect-Oriented Programming (AOP): Spring Boot leverages AOP to 
modularize cross-cutting concerns and separate them from the business 
logic. AOP allows you to define aspects that encapsulate reusable 
functionalities and apply them to different parts of the application through 
pointcut expressions.
Auto-Configuration: Spring Boot provides auto-configuration capabilities 
that automatically configure cross-cutting concerns based on the 
dependencies and libraries present in the classpath. It reduces the need for 
manual configuration and helps enforce best practices.
Starter Dependencies: Spring Boot starters include pre-configured 
dependencies for common cross-cutting concerns. By including these 
100+ Spring Boot Questions 21
starters in your project, you get the necessary libraries, configurations, and 
auto-configuration for handling these concerns effectively.
By addressing cross-cutting concerns, Spring Boot promotes modular and 
maintainable code, reduces code duplication, and provides a more cohesive and 
consistent architecture.
36. What is the purpose of the @Validated  annotation in Spring Boot?
The @Validated  annotation in Spring Boot is used to indicate that a class or 
method should be validated based on validation constraints defined by the Java 
Bean Validation API (JSR 380).
When you annotate a class or method with @Validated , Spring Boot 
automatically triggers the validation process on the annotated object or method 
arguments.
The @Validated  annotation can be used in conjunction with other validation-
related annotations, such as @Valid , to enforce validation rules on request 
payloads, command objects, or domain objects.
For example, consider the following code snippet:
@RestController 
public class MyController { 
    @PostMapping("/users") 
    public void createUser(@Validated @RequestBody User user) { 
        // ... 
    } 
} 
In this example, the @Validated  annotation is used to trigger validation on the User  
object received in the request body. If the User  object fails validation based on the 
defined constraints (e.g., not-null, pattern, size), Spring Boot automatically throws a 
MethodArgumentNotValidException .
The @Validated  annotation helps ensure data integrity and consistency by 
validating input or domain objects according to the specified validation 
constraints.
39. How can you enable Swagger documentation in a Spring Boot application?
Swagger is a popular framework for documenting and testing RESTful APIs. 
Spring Boot provides integration with Swagger through various libraries, such as 
Swagger UI and Springfox.
100+ Spring Boot Questions 22
To enable Swagger documentation in a Spring Boot application, you can follow 
these steps:
1. Include the necessary Swagger dependencies in your project's build 
configuration (e.g., Maven or Gradle). Spring Boot starters often include the 
required dependencies, so you may not need to add them explicitly.
2. Configure Swagger-related properties in the application.properties  or 
application.yml  file. For example, you can specify the API title, version, 
description, contact information, etc.
3. Annotate your RESTful controller methods with Swagger annotations, such 
as @ApiOperation , @ApiParam , and @ApiResponse . These annotations provide 
additional information about the API endpoints, request/response models, 
and error responses.
4. Run the application, and access the Swagger UI interface at the configured 
endpoint (e.g., http://localhost:8080/swagger-ui.html ). Swagger UI allows you 
to interactively explore and test your APIs, view the documentation, and 
even generate client SDKs.
Enabling Swagger documentation in a Spring Boot application enhances the 
developer experience by providing a clear and interactive representation of the 
available APIs, their parameters, and responses. It promotes API discoverability 
and simplifies API consumption by both developers and external consumers.
37. Explain the purpose of the @PathVariable  annotation in Spring Boot.
The @PathVariable  annotation in Spring Boot is used to extract and bind path 
variables from a URL to method parameters in a controller handler method.
When you define a mapping for a URL with variables, such as /users/{id} , the 
@PathVariable  annotation allows you to retrieve the value of the id  variable and 
use it in your method logic.
Here's an example:
@RestController 
public class UserController { 
    @GetMapping("/users/{id}") 
    public ResponseEntity<User> getUserById(@PathVariable Long id) { 
        // ... 
    } 
} 
100+ Spring Boot Questions 23
In this example, the getUserById  method maps to the /users/{id}  URL. The 
@PathVariable  annotation is used to bind the value of id  in the URL to the id  
parameter of the method.
When a request is made to /users/123 , Spring Boot automatically maps the value 
123  to the id  parameter, allowing you to retrieve and process the requested 
user with the ID 123 .
The @PathVariable  annotation simplifies the handling of path variables in Spring 
Boot and allows you to create dynamic and parameterized mappings in your 
RESTful APIs.
41. How does Spring Boot support message queuing?
Spring Boot provides integration with message queuing systems, such as 
RabbitMQ and Apache Kafka, through its Spring Integration and Spring AMQP 
modules.
Spring Boot's support for message queuing includes:
Starter Dependencies: Spring Boot starters for RabbitMQ and Apache 
Kafka provide the necessary dependencies and configurations to get started 
quickly.
Auto-Configuration: Spring Boot automatically configures the message 
queuing components based on the presence of the required dependencies 
and the configured properties.
Annotations: Spring Boot provides annotations, such as @RabbitListener  for 
RabbitMQ and @KafkaListener  for Apache Kafka, that simplify the creation of 
message consumers and event-driven architectures.
Integration with Spring Messaging: Spring Boot integrates with Spring 
Messaging and its abstractions, such as Message , MessageChannel , and 
MessageHandler , to facilitate the sending and receiving of messages.
With these features, Spring Boot simplifies the development of message-driven 
applications and enables the communication and integration of systems through 
message queuing systems.
42. What is the purpose of the @Scheduled  annotation in Spring Boot?
The @Scheduled  annotation in Spring Boot is used to schedule the execution of a 
method at fixed intervals or based on a cron expression.
100+ Spring Boot Questions 24
By annotating a method with @Scheduled , you can specify when and how often 
the method should be executed. The annotated method will be automatically 
invoked by Spring Boot's scheduling infrastructure according to the configured 
schedule.
Here's an example:
@Component 
public class MyScheduler { 
    @Scheduled(fixedDelay = 5000) // Executes every 5 seconds 
    public void doSomething() { 
        // ... 
    } 
} 
In this example, the doSomething  method is annotated with @Scheduled  and configured 
to execute every 5 seconds ( fixedDelay = 5000 ).
The @Scheduled  annotation is commonly used for tasks such as periodic data 
synchronization, cache refresh, report generation, or any other repetitive tasks.
Spring Boot's scheduling support provides a convenient way to automate such 
tasks, allowing you to focus on the business logic instead of manually managing 
timers or background threads.
43. Explain the concept of Actuator endpoints in Spring Boot.
Actuator endpoints in Spring Boot provide various management and monitoring 
capabilities for your application. These endpoints expose valuable information 
about the application's health, metrics, configurations, logging, and more.
Actuator endpoints are exposed as HTTP or JMX endpoints, allowing you to 
access the information through HTTP requests or JMX clients. Some commonly 
used Actuator endpoints include:
/health : Provides information about the application's health status, 
indicating whether it's up and running or experiencing any issues.
/info : Displays general information about the application, such as its name, 
version, and description.
/metrics : Provides various metrics about the application, such as CPU 
usage, memory usage, request counts, response times, and more.
/env : Displays the current environment properties and their values.
/loggers : Allows you to view and modify the logging configuration at runtime.
100+ Spring Boot Questions 25
Actuator endpoints provide a powerful tool for monitoring and managing your 
Spring Boot application in production environments. You can use them to gather 
insights, diagnose issues, perform health checks, adjust configurations, and gain 
operational visibility into your application.
44. How can you configure connection pooling in a Spring Boot application?
Spring Boot provides built-in support for connection pooling through its 
integration with popular connection pooling libraries, such as HikariCP, Apache 
Tomcat JDBC, and Commons DBCP2.
To configure connection pooling in a Spring Boot application, you can follow 
these steps:
1. Include the desired connection pooling library's dependency in your project's 
build configuration (e.g., Maven or Gradle).
2. Configure the connection pooling properties in the application.properties  or 
application.yml  file. The specific properties depend on the chosen 
connection pooling library. For example, if you're using HikariCP, you can set 
properties like spring.datasource.hikari.*  to configure the pool size, timeout, 
and other related settings.
3. Spring Boot automatically configures the data source bean based on the 
provided properties and the chosen connection pooling library.
Connection pooling improves application performance by reusing existing 
database connections instead of creating new connections for each request. It 
helps manage and optimize database connections, leading to better scalability 
and reduced overhead.
45. What is the purpose of the @CrossOrigin  annotation in Spring Boot?
The @CrossOrigin  annotation in Spring Boot is used to enable Cross-Origin 
Resource Sharing (CORS) for specific controller methods or the entire controller 
class.
CORS is a security mechanism implemented by web browsers that restricts 
cross-origin requests (requests made from different domains) for security 
reasons. By default, web browsers enforce the Same-Origin Policy, which 
prevents JavaScript code running in one domain from making requests to 
another domain.
The @CrossOrigin  annotation allows you to relax the browser's CORS restrictions 
and specify which origins, methods, headers, and other CORS-related 
100+ Spring Boot Questions 26
configurations are allowed for a particular controller method or class.
For example:
@RestController 
@CrossOrigin(origins = "<http://example.com>") 
public class MyController { 
    // ... 
} 
In this example, the @CrossOrigin  annotation is applied at the class level, allowing 
requests from http://example.com  to access the methods in the MyController  class.
By using @CrossOrigin , you can enable cross-origin requests and allow clients 
from different domains to access your Spring Boot APIs securely.
46. How does Spring Boot support internationalization and localization?
Spring Boot provides support for internationalization (i18n) and localization 
(l10n) through the use of message bundles and the MessageSource  interface.
To enable internationalization and localization in a Spring Boot application, you 
can follow these steps:
1. Define message properties files for different locales, such as 
messages_en.properties  for English, messages_fr.properties  for French, etc. 
These files contain key-value pairs representing the translated messages for 
each locale.
2. Configure the MessageSource  bean in the application context, specifying the 
base name(s) of the message properties files.
3. In your code, use the MessageSource  bean to retrieve the appropriate 
message based on the current locale.
Spring Boot automatically detects the locale based on the Accept-Language  
header in the HTTP request or by other means (e.g., browser settings) and 
resolves the appropriate message from the corresponding message properties 
file.
By leveraging Spring Boot's internationalization and localization support, you can 
create applications that adapt to different languages and cultures, providing a 
localized user experience.
47. Explain the concept of a health indicator in Spring Boot Actuator.
100+ Spring Boot Questions 27
In Spring Boot Actuator, a health indicator is a component responsible for 
providing information about the health status of a specific aspect of the 
application.
Health indicators are used by the /health  Actuator endpoint to provide insights 
into the overall health of the application. Each health indicator represents a 
specific subsystem, component, or dependency of the application and reports its 
health status as one of the predefined values: UP,
DOWN, OUT_OF_SERVICE, or UNKNOWN.
Spring Boot Actuator provides a set of built-in health indicators for common 
components, such as the database, message broker, disk space, and more. 
Additionally, you can define custom health indicators to monitor the health of 
specific application components or dependencies.
Custom health indicators implement the HealthIndicator  interface and override 
the health()  method to provide the health status based on custom checks or 
monitoring logic.
The health status reported by the health indicators can be used for monitoring, 
alerting, or automated health checks in your application infrastructure. It allows 
you to identify and diagnose potential issues, ensure high availability, and 
provide insights into the overall health of your Spring Boot application.
48. What is the purpose of the @RequestBody  annotation in Spring Boot?
The @RequestBody  annotation in Spring Boot is used to bind the body of an HTTP 
request to a method parameter in a controller handler method.
When you annotate a method parameter with @RequestBody , Spring Boot 
automatically converts the request body into the specified Java object. It uses a 
suitable HTTP message converter, based on the content type of the request, to 
perform the conversion.
For example, consider the following code snippet:
@RestController 
public class MyController { 
    @PostMapping("/users") 
    public void createUser(@RequestBody User user) { 
        // ... 
    } 
} 
100+ Spring Boot Questions 28
In this example, the createUser  method expects a User  object in the request body. 
The @RequestBody  annotation tells Spring Boot to deserialize the request body into a 
User  object automatically.
The @RequestBody  annotation is commonly used in RESTful APIs to extract and 
deserialize JSON or XML payloads from incoming requests.
49. How can you enable request logging in a Spring Boot application?
To enable request logging in a Spring Boot application, you can configure the 
logging level for the org.springframework.web  package to DEBUG  or TRACE . This can 
be done in the application.properties  or application.yml  file by adding the 
following line:
logging.level.org.springframework.web=DEBUG 
With this configuration, Spring Boot logs detailed information about incoming HTTP 
requests, including the request method, URL, headers, parameters, and other 
relevant details.
Additionally, you can customize the logging format and output by configuring a 
logging framework, such as Logback or Log4j, which are commonly used with 
Spring Boot.
Enabling request logging is helpful for debugging, troubleshooting, and auditing 
purposes. It allows you to monitor incoming requests and track the flow of data 
through your application.
50. Explain the purpose of the @ExceptionHandler  annotation in Spring Boot.
The @ExceptionHandler  annotation in Spring Boot is used to handle exceptions 
thrown by controller handler methods within the same controller or globally 
across multiple controllers.
By annotating a method with @ExceptionHandler , you can define custom exception 
handling logic to handle specific types of exceptions that may occur during 
request processing.
Here's an example:
@RestController 
public class MyController { 
    @ExceptionHandler(MyException.class) 
    public ResponseEntity<String> handleMyException(MyException ex) { 
        // Custom exception handling logic 
100+ Spring Boot Questions 29
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error
 occurred"); 
    } 
 
    // ... 
} 
In this example, the handleMyException  method is annotated with 
@ExceptionHandler(MyException.class) , indicating that it should handle MyException  
instances. Inside the method, you can define the appropriate response or perform 
any necessary error handling actions.
The @ExceptionHandler  annotation helps you centralize and customize the 
exception handling logic within your controllers. It allows you to provide 
meaningful error messages, handle specific exceptions, and return appropriate 
HTTP status codes or error responses to clients.
51. How does Spring Boot support asynchronous processing?
Spring Boot supports asynchronous processing through the use of the @Async  
annotation and the TaskExecutor  interface.
To enable asynchronous processing, you need to follow these steps:
1. Annotate a method with @Async  to indicate that it should be executed 
asynchronously.
2. Configure a TaskExecutor  bean in the application context. Spring Boot 
provides sensible defaults, but you can also customize the thread pool size 
and other settings.
3. Call the asynchronous method from another method. The method will be 
executed in a separate thread, allowing the calling thread to continue 
processing other tasks.
Here's an example:
@Service 
public class MyService { 
    @Async 
    public CompletableFuture<String> doSomethingAsync() { 
        // Asynchronous processing logic 
        // ... 
        return CompletableFuture.completedFuture("Result"); 
    } 
} 
100+ Spring Boot Questions 30
In this example, the doSomethingAsync  method is annotated with @Async , indicating 
that it should be executed asynchronously. The method returns a CompletableFuture  
that allows you to handle the result of the asynchronous operation.
Spring Boot's support for asynchronous processing improves application 
responsiveness, scalability, and resource utilization by offloading time-consuming 
tasks to separate threads. It allows you to perform parallel processing, invoke 
external services asynchronously, or handle long-running operations without 
blocking the main execution thread.
52. What is the purpose of the @EnableAutoConfiguration  annotation in Spring 
Boot?
The @EnableAutoConfiguration  annotation in Spring Boot is used to enable the 
auto-configuration feature, which automatically configures the Spring application 
context based on the classpath dependencies, beans, and properties present in 
the application.
By adding @EnableAutoConfiguration  to a configuration class or the main 
application class, Spring Boot performs classpath scanning and automatically 
configures various aspects of the application, such as data sources, JPA, 
messaging, web, security, and more. It leverages the Spring Boot starters, which 
provide pre-packaged configurations and dependencies for common use cases.
The auto-configuration feature reduces the need for manual configuration, 
boilerplate code, and tedious bean wiring. It promotes convention over 
configuration and allows developers to focus on the business logic rather than 
the low-level setup details.
The @EnableAutoConfiguration  annotation is typically used in the main application 
class of a Spring Boot application.
53. How can you configure a connection pool in Spring Boot?
In Spring Boot, you can configure a connection pool by providing the necessary 
properties for the connection pool library you are using. Spring Boot supports 
multiple connection pooling libraries, such as HikariCP, Apache Tomcat JDBC, 
and Commons DBCP2.
The specific configuration properties and their values depend on the chosen 
connection pooling library. For example, if you're using HikariCP, you can 
configure the connection pool properties in the application.properties  or 
application.yml  file with the prefix spring.datasource.hikari.* .
Here's an example configuration for HikariCP in application.properties :
100+ Spring Boot Questions 31
spring.datasource.hikari.jdbc-url=jdbc:mysql://localhost:3306/mydb 
spring.datasource.hikari.username=dbuser 
spring.datasource.hikari.password=dbpass 
spring.datasource.hikari.maximum-pool-size=10 
In this example, the spring.datasource.hikari.*  properties configure the URL, 
username, password, and maximum pool size for the HikariCP connection pool.
By configuring the appropriate properties for your chosen connection pooling 
library, Spring Boot automatically sets up the connection pool and manages 
database connections efficiently.
54. Explain the concept of transaction management in Spring Boot.
Transaction management in Spring Boot allows you to define and manage 
database transactions declaratively, without writing low-level transaction 
handling code.
Spring Boot supports transaction management through integration with the Java 
Transaction API (JTA), Java Persistence API (JPA), and other transaction 
management frameworks.
To use transaction management in Spring Boot, you typically need to:
1. Configure a data source and transaction manager in the application context.
2. Annotate the service methods or classes that require transaction 
management with @Transactional . This annotation ensures that the 
annotated methods are executed within a transactional context.
Spring Boot's transaction management provides features such as:
ACID Transactions: Spring Boot handles the creation, commit, or rollback 
of transactions, ensuring data consistency and integrity.
Declarative Transaction Management: With @Transactional  annotation, you 
can specify the transactional behavior (e.g., isolation level, propagation) at 
the method or class level, simplifying the transaction handling code.
Exception Handling: Spring Boot automatically rolls back the transaction if 
an exception occurs, ensuring that the database state remains consistent.
Transaction management in Spring Boot enables reliable and consistent 
database operations, making it easier to develop applications with complex data 
interactions.
100+ Spring Boot Questions 32
55. What is the purpose of the @Async  annotation in Spring Boot?
The @Async  annotation in Spring Boot is used to mark a method as 
asynchronous, indicating that it should be executed in a separate thread.
By annotating a method with @Async , Spring Boot automatically runs the method 
asynchronously, allowing the calling thread to continue with other tasks without 
waiting for the asynchronous method to complete.
Here's an example:
@Service 
public class MyService { 
    @Async 
    public void doSomethingAsync() { 
        // Asynchronous processing logic 
        // ... 
    } 
}
In this example, the doSomethingAsync  method is annotated with @Async , indicating 
that it should be executed asynchronously. The method will run in a separate thread 
managed by Spring's task executor.
The @Async  annotation is typically used for time-consuming or non-blocking 
operations, such as sending emails, performing background tasks, or invoking 
external services, without blocking the main execution thread.
Spring Boot's support for asynchronous processing helps improve application 
performance, responsiveness, and scalability by offloading time-consuming tasks 
to separate threads. It allows for parallel processing and efficient utilization of 
system resources.
56. How does Spring Boot handle security vulnerabilities, such as Cross-Site 
Scripting (XSS) and Cross-Site Request Forgery (CSRF)?
Spring Boot provides security features and mechanisms to help mitigate security 
vulnerabilities, including XSS and CSRF attacks.
Cross-Site Scripting (XSS): Spring Boot includes protection against XSS 
attacks by automatically escaping user input in web pages using template 
engines, such as Thymeleaf or FreeMarker. Additionally, Spring Security 
provides features like Content Security Policy (CSP) and XSS protection 
headers to prevent XSS attacks.
100+ Spring Boot Questions 33
Cross-Site Request Forgery (CSRF): Spring Boot integrates with Spring 
Security to provide CSRF protection. It automatically generates and includes 
CSRF tokens in forms or AJAX requests, preventing CSRF attacks by 
verifying the authenticity of requests.
To further enhance security, Spring Boot encourages best practices, such as 
input validation, output encoding, secure session management, and secure 
communication protocols (e.g., HTTPS).
It's important to note that while Spring Boot provides security features, it's the 
responsibility of developers to properly configure and utilize these features, as 
well as follow secure coding practices, to protect against security vulnerabilities.
57. What is the purpose of the @Cacheable  annotation in Spring Boot?
The @Cacheable  annotation in Spring Boot is used to enable method-level 
caching. By annotating a method with @Cacheable , Spring Boot caches the result 
of the method invocation based on the method parameters, allowing subsequent 
invocations to be served from the cache instead of executing the method.
Caching is useful for methods that have expensive or time-consuming 
computations, database queries, or remote calls, where the result is expected to 
be the same for the same set of input parameters.
Here's an example:
@Service 
public class MyService { 
    @Cacheable("myCache") 
    public String getDataFromDatabase(String key) { 
        // Expensive database query 
        // ... 
        return data; 
    } 
}
In this example, the getDataFromDatabase  method is annotated with @Cacheable  and 
configured to use the cache named "myCache". When this method is invoked with 
the same key  parameter, Spring Boot checks the cache first. If the data is present in 
the cache, it returns the cached value; otherwise, it executes the method and caches 
the result for subsequent invocations.
The @Cacheable  annotation helps improve performance by avoiding redundant 
computations or expensive operations, especially in scenarios where the data 
doesn't change frequently.
100+ Spring Boot Questions 34
58. How can you handle file uploads in a Spring Boot application?
To handle file uploads in a Spring Boot application, you can follow these steps:
1. Configure file upload properties in the application.properties  or 
application.yml  file. Specify the maximum allowed file size, location to store 
uploaded files, and other related settings.
2. Create a controller method to handle the file upload request. Annotate the 
method with @PostMapping  and @RequestParam("file")  to receive the uploaded 
file.
3. Use a MultipartFile  parameter to bind the uploaded file to the method. The 
MultipartFile  class provides methods to access the file's content, name, 
size, and other attributes.
4. Process the uploaded file as required. You can save the file to a location, 
perform validation or processing, or store the file content in a database.
Here's an example:
@RestController 
public class FileUploadController { 
    @PostMapping("/upload") 
    public ResponseEntity<String> uploadFile(@RequestParam("file") MultipartFile file) 
{ 
        // 
 
Process the uploaded file 
        // ... 
        return ResponseEntity.ok("File uploaded successfully"); 
    } 
} 
With this configuration, the Spring Boot application can handle file uploads and 
process the uploaded files based on your application's requirements.
59. Explain the concept of circuit breakers in Spring Boot.
Circuit breakers are a design pattern used to handle and prevent cascading 
failures in distributed systems. In Spring Boot, the circuit breaker pattern is 
implemented through libraries such as Netflix Hystrix or Resilience4j.
The concept of a circuit breaker involves three states: closed, open, and half-
open.
Closed: In the closed state, the circuit breaker allows the execution of 
requests as normal. It monitors the success and failure rates of requests.
100+ Spring Boot Questions 35
Open: If the failure rate exceeds a certain threshold, the circuit breaker 
transitions to the open state. In this state, all requests are immediately 
rejected, and an exception or fallback response is returned without executing
the actual operation. This helps prevent further requests to a failing or 
unresponsive component.
Half-Open: After a specified timeout, the circuit breaker enters the half-open 
state. In this state, a limited number of requests are allowed to pass through 
to check if the underlying operation or component has recovered. If these 
requests succeed, the circuit breaker transitions back to the closed state. 
Otherwise, it goes back to the open state.
Circuit breakers provide fault tolerance and resilience by isolating failing or 
unresponsive components and preventing them from affecting the overall 
system. They also provide fallback mechanisms to handle errors or degraded 
responses during failure scenarios.
Spring Boot integrates with circuit breaker libraries, allowing you to annotate 
methods with @CircuitBreaker  or use configuration properties to define circuit-
breaking behavior for specific operations or external service invocations.
60. What is the purpose of the @ControllerAdvice  annotation in Spring Boot?
The @ControllerAdvice  annotation in Spring Boot is used to define global 
exception handling and common functionality for multiple controllers.
By annotating a class with @ControllerAdvice , you can define global exception 
handling methods that apply to multiple controllers. These methods can handle 
exceptions thrown by controller handler methods and provide centralized error 
handling logic.
Additionally, @ControllerAdvice  allows you to define reusable functionality, such 
as model attribute bindings, @InitBinder  methods, or @ModelAttribute  methods, 
that can be shared across multiple controllers.
Here's an example of using @ControllerAdvice  for global exception handling:
@ControllerAdvice 
public class GlobalExceptionHandler { 
    @ExceptionHandler(Exception.class) 
    public ResponseEntity<String> handleException(Exception ex) { 
        // Custom exception handling logic 
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("An error
 occurred"); 
    } 
}
100+ Spring Boot Questions 36
In this example, the handleException  method is annotated with @ExceptionHandler  and 
can handle any exception. It provides custom error handling logic and returns an 
appropriate HTTP response.
The @ControllerAdvice  annotation helps centralize common functionality and 
exception handling in a Spring Boot application, promoting code reuse and 
maintainability.
61. How does Spring Boot handle database connections and pooling?
Spring Boot provides support for managing database connections and 
connection pooling through its integration with data access frameworks like 
Spring Data JPA, JDBC, and MyBatis.
When you configure a data source in a Spring Boot application, Spring Boot 
automatically sets up and manages a connection pool based on the chosen 
connection pooling library, such as HikariCP, Apache Tomcat JDBC, or 
Commons DBCP2.
The specific connection pooling library and its configuration properties can be 
specified in the application.properties  or `application.yml` file.
Spring Boot provides sensible default configurations for connection pooling, but 
you can also customize the pool size, maximum connections, connection 
timeout, and other related settings based on your application's requirements.
The connection pool manages and reuses database connections, reducing the 
overhead of creating new connections for each database interaction. This 
improves performance and scalability by efficiently managing the resources 
required for database connections.
Additionally, Spring Boot supports transaction management to ensure the proper 
handling of database transactions, including automatic rollback on exceptions 
and coordination of multiple data sources in distributed transactions.
62. What is the purpose of the @RestControllerAdvice  annotation in Spring Boot?
The @RestControllerAdvice  annotation in Spring Boot combines the functionalities 
of @ControllerAdvice  and @ResponseBody . It is used to define global exception 
handling and common functionality specifically for RESTful APIs.
By annotating a class with @RestControllerAdvice , you can define global exception 
handling methods that apply to multiple REST controllers. These methods can 
handle exceptions thrown by controller handler methods and provide centralized 
error handling logic. Additionally, the @RestControllerAdvice  annotation 
100+ Spring Boot Questions 37
automatically serializes the response returned by these methods into the 
appropriate response format, such as JSON.
@RestControllerAdvice  can also be used to define common functionality, such as 
model attribute bindings, @InitBinder  methods, or @ModelAttribute  methods, that 
are shared across multiple REST controllers.
The @RestControllerAdvice  annotation helps centralize common functionality and 
exception handling specifically for RESTful APIs, improving code reuse and 
maintainability.
63. Explain the concept of lazy initialization in Spring Boot.
Lazy initialization is a concept in Spring Boot where a bean is created only when 
it is first requested instead of eagerly creating it during the application startup. 
This is also known as on-demand initialization.
By default, Spring Boot beans are lazily initialized, which means they are created 
and instantiated when they are first accessed in the application. This can 
improve application startup time and resource utilization by avoiding the 
unnecessary creation of beans that may not be immediately required.
However, it's important to note that lazy initialization may result in a slight delay 
when accessing the bean for the first time. If you require eager initialization for a 
bean, you can use the @Lazy(false)  annotation on the bean declaration.
Lazy initialization is especially useful when working with large applications or 
scenarios where certain beans are infrequently used or have expensive 
instantiation logic. It allows for more efficient resource allocation and improves 
overall application performance.
64. How can you configure a custom data source in Spring Boot?
To configure a custom data source in Spring Boot, you need to follow these 
steps:
1. Add the database driver dependency to your project's build configuration 
(e.g., Maven or Gradle).
2. Create a class that implements the DataSource  interface or extends a data 
source implementation, such as BasicDataSource , HikariDataSource , or 
TomcatDataSource .
3. Configure the data source properties, such as URL, username, password, 
driver class, and any additional configuration specific to the data source 
implementation.
100+ Spring Boot Questions 38
4. Annotate the data source bean creation method with @Bean  in a 
configuration class.
Here's an example of configuring a custom data source using HikariCP:
@Configuration 
public class DataSourceConfig { 
    @Bean 
    public DataSource dataSource() { 
        HikariConfig config = new HikariConfig(); 
        config.setJdbcUrl("jdbc:mysql://localhost:3306/mydb"); 
        config.setUsername("username"); 
        config.setPassword("password"); 
        // Additional configuration... 
 
        return new HikariDataSource(config); 
    } 
} 
In this example, a custom data source using HikariCP is configured with the 
necessary properties. The dataSource()  method is annotated with @Bean  to indicate 
that it should be managed as a bean by Spring Boot.
With the custom data source configured, you can use it in other components or 
configure persistence-related beans, such as JdbcTemplate , EntityManagerFactory , 
or DataSourceTransactionManager .
65. What is the purpose of the @Profile  annotation in Spring Boot?
The @Profile  annotation in Spring
Boot is used to activate or deactivate specific configurations, beans, or 
components based on the specified profile(s).
By associating the @Profile  annotation with a class or method, you can control 
when that class or method should be considered for configuration and bean 
creation based on the active profiles.
For example, consider the following code snippet:
@Component 
@Profile("dev") 
public class DevelopmentComponent { 
    // Development-specific configuration and logic 
} 
100+ Spring Boot Questions 39
In this example, the DevelopmentComponent  is annotated with @Profile("dev") , indicating 
that it should only be considered for configuration and bean creation when the "dev" 
profile is active.
Profiles can be activated through various means, such as environment variables, 
system properties, or the spring.profiles.active  property in the 
application.properties  or application.yml  file.
The @Profile  annotation provides a powerful mechanism for creating different 
configurations or customizing behavior based on different runtime environments, 
such as development, testing, staging, or production.
66. How does Spring Boot handle authentication and authorization?
Spring Boot provides integration with Spring Security, which is a powerful 
framework for handling authentication and authorization in Java applications.
Authentication is the process of verifying the identity of a user, while 
authorization involves granting or denying access to specific resources based on 
the user's role or permissions.
Spring Boot and Spring Security offer a wide range of features to handle 
authentication and authorization, including:
Authentication Providers: Spring Boot supports various authentication 
providers, such as in-memory user credentials, database-backed 
authentication, LDAP, OAuth, and more.
User Management: Spring Security provides features for user management, 
password encoding, and password policy enforcement.
Authorization: Spring Security allows you to define access control rules and 
permissions using annotations, XML configurations, or through method-level 
security.
Form-based Authentication: Spring Boot supports form-based 
authentication, allowing users to authenticate through a login form.
Token-based Authentication: Spring Boot supports token-based 
authentication, such as JSON Web Tokens (JWT), which eliminates the 
need for session management.
Additionally, Spring Security integrates well with other Spring Boot components, 
such as Spring Data, allowing for seamless integration of authentication and 
authorization with database-backed user stores.
100+ Spring Boot Questions 40
By leveraging the features provided by Spring Boot and Spring Security, you can 
secure your applications and protect sensitive resources from unauthorized 
access.
67. What is the purpose of the @Bean  annotation in Spring Boot?
The @Bean  annotation in Spring Boot is used to indicate that a method produces 
a bean to be managed by the Spring application context.
By annotating a method with @Bean , you define a bean creation method that 
Spring Boot will invoke to instantiate and configure the object. The returned 
object from the method will be managed by the Spring container, and its lifecycle 
will be handled by Spring.
Here's an example:
@Configuration 
public class MyConfiguration { 
    @Bean 
    public MyBean myBean() { 
        return new MyBean(); 
    } 
}
In this example, the myBean()  method is annotated with @Bean , indicating that it 
produces a bean of type MyBean . When the Spring container is initialized, it will 
invoke this method and register the returned MyBean  instance as a managed bean.
The @Bean  annotation allows you to control the instantiation, configuration, and 
lifecycle management of objects in the Spring container. It's commonly used to 
define custom beans, third-party integrations, or to customize the behavior of 
existing beans.
68. How can you enable server-side validation in a Spring Boot application?
Server-side validation in a Spring Boot application can be enabled by using the 
validation capabilities provided by the Java Bean Validation API (JSR 380) and 
Spring's validation framework.
To enable server-side validation, you can follow these steps:
1. Include the necessary dependencies for validation, such as spring-boot-
starter-validation  or javax.validation .
100+ Spring Boot Questions 41
2. Annotate the model classes or request DTOs with validation annotations, 
such as @NotNull , @NotEmpty , @Min , @Max , or custom annotations.
3. In the controller or service methods, annotate the request parameters or 
method arguments with @Valid  to trigger the validation process.
4. Handle the validation errors by using Spring's validation results, such as 
BindingResult , or by throwing exceptions.
Here's an example:
@PostMapping("/users") 
public ResponseEntity<String> createUser(@Valid @RequestBody User user, BindingResult
 bindingResult) { 
    if (bindingResult.hasErrors()) { 
        // Handle validation errors 
        // ... 
    } 
    // ... 
}
In this example, the createUser  method receives a User  object in the request body 
and validates it using @Valid . The validation errors are captured in the BindingResult , 
allowing you to handle the errors appropriately.
Server-side validation helps ensure the integrity and validity of user input, 
preventing the processing of invalid or malicious data and improving the overall 
quality of your application.
69. Explain the concept of the Spring Boot Starter Parent.
The Spring Boot Starter Parent is a special Maven parent project provided by the 
Spring Boot framework. It serves as a parent POM for your Spring Boot 
application, providing default configurations, dependencies, and plugins to 
simplify the setup and build process.
When you use the Spring Boot Starter Parent as your project's parent, it brings 
several benefits:
Default Configurations: The parent POM provides sensible default 
configurations for your project, such as the Java version, encoding, resource 
filtering, and plugin configurations.
Dependency Management: The Spring Boot Starter Parent manages the 
versions of various Spring Boot dependencies, ensuring compatibility and 
reducing the need for explicit version declarations in your project's POM.
100+ Spring Boot Questions 42
Spring Boot Plugins: The parent POM includes useful Maven plugins, such 
as the Spring Boot Maven Plugin, which allows you to package and run your 
application easily.
By using the Spring Boot Starter Parent, you inherit a set of recommended 
configurations and best practices, making it easier to develop and maintain your 
Spring Boot application.
70. What is the purpose of the @ResponseBody  annotation in Spring Boot?
The @ResponseBody  annotation in Spring Boot is used to indicate that the return 
value of a controller method should be serialized directly into the HTTP response 
body.
When you annotate a method with @ResponseBody , Spring Boot automatically 
converts the method's return value to the appropriate response format, such as 
JSON, XML, or plain text, based on the request's Accept  header.
Here's an example:
@RestController 
public class MyController { 
    @GetMapping("/hello") 
    @ResponseBody 
    public String sayHello() { 
        return "Hello, World!"; 
    } 
}
In this example, the sayHello  method returns a String , and it is annotated with 
@ResponseBody . Spring Boot serializes the returned string into the response body, 
allowing it to be sent back to the client.
The @ResponseBody  annotation is often used in combination with @RestController , 
where all handler methods are implicitly
annotated with @ResponseBody . It eliminates the need for explicit @ResponseBody  
annotations on each method.
The @ResponseBody  annotation is particularly useful when developing RESTful 
APIs, as it simplifies the process of returning structured data in the desired 
format.
71. How does Spring Boot support handling of JSON data?
Spring Boot provides built-in support for handling JSON data through its 
integration with Jackson, a popular JSON library for Java.
100+ Spring Boot Questions 43
When working with JSON data in a Spring Boot application, you can perform the 
following tasks:
Request and Response Binding: Spring Boot can automatically bind JSON 
data from HTTP requests to Java objects using the @RequestBody  annotation. 
It also serializes Java objects into JSON format for HTTP responses using 
the @ResponseBody  annotation.
Custom JSON Serialization/Deserialization: Spring Boot allows you to 
customize the JSON serialization and deserialization process by providing 
custom serializers, deserializers, or mixins.
JSON Content Negotiation: Spring Boot supports content negotiation, 
allowing clients to request JSON data by setting the appropriate Accept  
header. It can also handle different media types, such as XML, based on the 
client's preference.
JSON Property Naming Strategies: Spring Boot provides options to 
configure the naming strategy for JSON properties, such as camel case, 
snake case, or custom naming conventions.
By default, Spring Boot uses Jackson as the default JSON provider. However, 
you can also choose other JSON libraries, such as Gson or JSON-B, by 
including the necessary dependencies and configuring them accordingly.
Spring Boot's JSON support simplifies the process of handling JSON data in 
your application, allowing for seamless integration with RESTful APIs and 
efficient communication between clients and servers.
72. What is the purpose of the @EnableScheduling  annotation in Spring Boot?
The @EnableScheduling  annotation in Spring Boot is used to enable the scheduling 
of tasks and methods based on a fixed delay, fixed rate, or cron expression.
By annotating a configuration class or the main application class with 
@EnableScheduling , Spring Boot enables the scheduling infrastructure, which 
allows you to define scheduled tasks using the @Scheduled  annotation.
Here's an example:
@Configuration 
@EnableScheduling 
public class SchedulingConfig { 
    // Scheduled task 
    @Scheduled(fixedDelay = 5000) 
    public void myTask() { 
100+ Spring Boot Questions 44
        // Task logic 
        // ... 
    } 
}
In this example, the SchedulingConfig  class is annotated with @EnableScheduling , 
enabling the scheduling infrastructure. The myTask  method is annotated with 
@Scheduled  and scheduled to run with a fixed delay of 5000 milliseconds (5 seconds).
Spring Boot's scheduling support simplifies the implementation of time-based 
tasks, such as periodic data synchronization, cache refresh, or batch processing, 
without the need for external libraries or complex configuration.
73. How can you configure error handling in a Spring Boot application?
In a Spring Boot application, you can configure error handling in several ways, 
depending on your requirements and preferences:
Global Exception Handling: You can use the @ControllerAdvice  annotation 
to define global exception handling methods that apply to multiple 
controllers. These methods can handle exceptions and provide centralized 
error handling logic.
Controller-specific Exception Handling: You can define exception 
handling methods within individual controllers using the @ExceptionHandler  
annotation. These methods handle exceptions specific to a particular 
controller or REST endpoint.
Custom Error Pages: Spring Boot allows you to configure custom error 
pages by creating HTML or Thymeleaf templates in the 
src/main/resources/templates/error  directory. These templates are rendered 
when an error occurs, providing a custom error page for different HTTP error 
statuses.
Custom Error Handling Logic: You can implement custom error handling 
logic by implementing the ErrorController  interface or extending the 
ResponseEntityExceptionHandler  class. This allows you to have fine-grained 
control over the error handling process.
By utilizing these approaches, you can effectively handle and manage different 
types of errors, exceptions, and HTTP status codes in your Spring Boot 
application.
74. Explain the concept of a RESTful API in Spring Boot.
100+ Spring Boot Questions 45
A RESTful API (Representational State Transfer) in Spring Boot is an 
architectural style for building web services that follow the principles of REST. It 
provides a standard set of guidelines and constraints for designing, 
implementing, and interacting with web services.
In a RESTful API, resources are represented as URLs (Uniform Resource 
Locators), and clients interact with these resources using HTTP methods (GET, 
POST, PUT, DELETE) and standard HTTP status codes.
Spring Boot simplifies the development of RESTful APIs by providing features 
and integrations that align with the RESTful principles:
HTTP Verbs and Endpoints: Spring Boot allows you to define REST 
endpoints using @RequestMapping  or more specialized annotations like 
@GetMapping , @PostMapping , @PutMapping , and @DeleteMapping . These 
annotations map the endpoints to corresponding HTTP methods.
Request and Response Serialization: Spring Boot integrates with libraries 
like Jackson or Gson to automatically serialize and deserialize request and 
response payloads in JSON or other formats.
Error Handling: Spring Boot provides mechanisms for handling and 
returning appropriate HTTP status codes and error messages for different 
scenarios, such as validation errors, resource not found, or server errors.
Content Negotiation: Spring Boot supports content negotiation, allowing 
clients to request different media types (JSON, XML, etc.) based on their 
preferences. It can automatically marshal and unmarshal data in the 
requested format.
HATEOAS: Spring HATEOAS, a part of the Spring Boot ecosystem, enables 
the implementation of HATEOAS (Hypermedia as the Engine of Application 
State) by adding hypermedia links to API responses, allowing clients to 
navigate through the API dynamically.
By following RESTful principles and utilizing the features provided by Spring 
Boot, you can design and develop robust, scalable, and interoperable APIs that 
provide a uniform interface for clients to interact with your application.
75. What is the purpose of the @Entity  annotation in Spring Boot?
The @Entity  annotation in Spring Boot is used to mark a class as a persistent 
entity. It is typically applied to POJOs (Plain Old Java Objects) that represent 
100+ Spring Boot Questions 46
entities in a relational database.
By annotating a class with @Entity , you indicate to the Spring Boot framework 
that instances of this class should be mapped to corresponding database tables. 
It enables Spring Data JPA to automatically generate the necessary SQL queries 
for CRUD operations and provides object-relational mapping (ORM) capabilities.
Additionally, the @Entity  annotation allows you to specify metadata about the 
entity, such as the table name, primary key, relationships with other entities, and 
validation constraints using annotations like @Table , @Id , @GeneratedValue , 
@Column , etc.
Here's an example:
@Entity 
@Table(name = "users") 
public class User { 
    @Id 
    @GeneratedValue(strategy = GenerationType.IDENTITY) 
    private Long id; 
 
    @Column(name = "username") 
    private String username; 
 
    // Getters and setters, constructors, other fields, and methods... 
}
In this example, the User  class is marked as an entity using the @Entity  annotation. 
The @Table  annotation specifies the name of the corresponding database table. The 
@Id  and @GeneratedValue  annotations define the primary key strategy, and the 
@Column  annotation maps the username  field to the corresponding column in the table.
The @Entity  annotation plays a crucial role in enabling the persistence and ORM 
capabilities provided by Spring Boot and Spring Data JPA.
76. How does Spring Boot handle distributed transactions?
Spring Boot provides support for distributed transactions through the integration 
with Java Transaction API (JTA) and the use of distributed transaction 
managers.
By default, Spring Boot uses the DataSourceTransactionManager  for handling local 
transactions within a single data source. However, when working with distributed 
transactions involving multiple data sources or external resources, you need to 
configure a JTA transaction manager.
100+ Spring Boot Questions 47
To enable distributed transactions in a Spring Boot application, you typically 
perform the following steps:
1. Configure the JTA transaction manager, such as Atomikos or Bitronix, as a 
dependency.
2. Configure the JTA transaction manager as the primary transaction manager 
in the application configuration.
3. Annotate the transactional methods or classes with @Transactional  to 
demarcate the boundaries of the transaction.
With the JTA transaction manager configured and @Transactional  annotations 
applied, Spring Boot coordinates the distributed transactions across multiple 
resources, such as databases, message queues, or external systems.
It's important to note that enabling distributed transactions requires additional 
configuration and coordination between the transaction manager and 
participating resources. Distributed transactions should be used with caution due 
to the increased complexity and potential performance impact.
77. What is the purpose of the @PathVariable  annotation in Spring Boot?
The @PathVariable  annotation in Spring Boot is used to extract values from the 
URI path and bind them to method parameters.
When you define a RESTful endpoint with a dynamic portion in the URL path, 
such as /users/{id} , the @PathVariable  annotation allows you to retrieve the 
value of {id}  and use it in your controller method.
Here's an example:
@RestController 
public class UserController { 
    @GetMapping("/users/{id}") 
    public ResponseEntity<User> getUserById(@PathVariable Long id) { 
        // Logic to fetch user by ID 
        // ... 
    } 
}
In this example, the getUserById  method is annotated with @GetMapping  and defines a 
path /users/{id} . The @PathVariable  annotation on the id  parameter indicates that 
the value extracted from the URI path should be assigned to the id  parameter.
100+ Spring Boot Questions 48
When a request is made to /users/123 , the getUserById  method is invoked with 
id  set to 123 .
The @PathVariable  annotation provides a convenient way to extract dynamic 
values from the URL path and use them in your controller methods, allowing for 
flexible and parameterized request handling.
78. How can you enable method-level security in a Spring Boot application?
Method-level security in a Spring Boot application can be enabled by integrating 
Spring Security and configuring access control rules for individual methods or 
endpoints.
To enable method-level security, you need to follow these steps:
1. Include the necessary dependencies for Spring Security in your project.
2. Create a security configuration class that extends 
WebSecurityConfigurerAdapter  and override the configure  method.
3. Within the configure  method, use @EnableGlobalMethodSecurity  to enable 
method-level security and specify the desired security expression language 
(SpEL) configuration, such as @EnableGlobalMethodSecurity(prePostEnabled = 
true) .
4. Annotate the desired methods or classes with security annotations, such as 
@PreAuthorize , @PostAuthorize , @Secured , or @RolesAllowed , to define access 
control rules.
Here's an example:
@Configuration 
@EnableGlobalMethodSecurity(prePostEnabled = true) 
public class SecurityConfig extends WebSecurityConfigurerAdapter { 
    // Configure authentication and authorization settings 
 
    @Override 
    protected void configure(HttpSecurity http) throws Exception { 
        // Configure HTTP security settings 
    } 
} 
 
@RestController 
public class MyController { 
    @PreAuthorize("hasRole('ROLE_ADMIN')") 
    @GetMapping("/admin") 
    public ResponseEntity<String> adminEndpoint() { 
        // Accessible only to users with the ROLE_ADMIN role 
        // ... 
100+ Spring Boot Questions 49
    } 
}
In this example, the SecurityConfig  class is annotated with @Configuration  and 
@EnableGlobalMethodSecurity(prePostEnabled = true) , enabling method-level security with 
pre/post authorization checks. The MyController  class has an endpoint that is only 
accessible to users with the ROLE_ADMIN  role, enforced by the @PreAuthorize  
annotation.
Method-level security allows you to define fine-grained access control rules for 
specific methods or endpoints, providing an additional layer of security to your 
Spring Boot application.
79. Explain the concept of reactive programming in Spring Boot.
Reactive programming is a programming paradigm that focuses on handling 
asynchronous and event-driven scenarios, allowing applications to handle a 
large number of concurrent requests with a small number of threads. It provides 
non-blocking I/O and efficient resource utilization, making it suitable for highly 
scalable and responsive systems.
Spring Boot supports reactive programming through the Spring WebFlux 
module, which is built on the Reactive Streams specification. It allows you to 
build reactive applications using a functional programming style or the traditional 
annotation-based programming model.
The key concepts in reactive programming include:
Reactive Streams: The Reactive Streams specification provides a standard 
for asynchronous stream processing with non-blocking back pressure. It 
defines interfaces for publishers, subscribers, and processors to handle data 
streams in a reactive manner.
Mono and Flux: In Spring WebFlux, the Mono  represents a stream with zero 
or one element, while Flux  represents a stream with zero or more elements. 
These types allow you to work with asynchronous sequences of data and 
apply reactive operators to transform, combine, or consume the data.
WebFlux Annotations: Spring WebFlux provides annotations such as 
@RestController , @GetMapping , @PostMapping , etc., similar to the annotations 
used in traditional Spring MVC. However, the underlying execution model is 
non-blocking and reactive.
100+ Spring Boot Questions 50
Reactive programming in Spring Boot offers benefits such as scalability, 
responsiveness, and efficient resource utilization, especially in scenarios with 
high concurrency and I/O-bound operations.
80. What is the purpose of the @RepositoryRestResource  annotation in Spring 
Boot?
The @RepositoryRestResource  annotation in Spring Boot is used to expose Spring 
Data repositories as RESTful resources.
When you apply the @RepositoryRestResource  annotation to a repository interface 
or class, Spring Boot automatically generates RESTful endpoints for CRUD 
operations on the repository entities. These endpoints follow the conventions of 
the Richardson Maturity Model and support standard HTTP methods and status 
codes.
The @RepositoryRestResource  annotation allows you to customize the behavior and 
appearance of the generated REST endpoints by providing attributes such as 
path , collectionResourceRel , itemResourceRel , and excerptProjection .
Here's an example:
@RepositoryRestResource(path = "products") 
public interface ProductRepository extends JpaRepository<Product, Long> { 
    // Custom repository methods... 
}
In this example, the ProductRepository  interface is annotated with 
@RepositoryRestResource  and configured with a custom path of "/products". Spring 
Boot generates RESTful endpoints for managing Product  entities, such as GET 
/products , POST /products , PUT /products/{id} , and so on.
The @RepositoryRestResource  annotation simplifies the process of exposing Spring 
Data repositories as RESTful resources, allowing you to quickly build RESTful 
APIs for your data entities without writing boilerplate code.
81. How does Spring Boot support the creation of microservices?
Spring Boot provides various features and integrations that facilitate the 
development of microservices, which are small, loosely coupled, and 
independently deployable components that work together to form a larger 
application.
Some ways in which Spring Boot supports the creation of microservices include:
100+ Spring Boot Questions 51
Lightweight and Opinionated: Spring Boot simplifies the setup and 
configuration of microservices by providing a lightweight framework with 
sensible defaults and opinionated auto-configuration. It reduces the need for 
manual configuration and boilerplate code.
Embedded Servlet Container: Spring Boot includes an embedded servlet 
container, such as Tomcat, Jetty, or Undertow, eliminating the need for a 
separate application server for deployment. This makes it easier to package 
and deploy microservices as standalone executable JAR files.
Microservice Architecture Patterns: Spring Boot supports architectural 
patterns commonly used in microservices, such as service registration and 
discovery (e.g., with Spring Cloud Netflix Eureka), load balancing (e.g., with 
Spring Cloud Netflix Ribbon), and circuit breakers (e.g., with Spring Cloud 
Netflix Hystrix).
Spring Cloud: Spring Boot integrates seamlessly with Spring Cloud, which 
provides additional capabilities for building distributed systems and 
implementing cloud-native patterns, such as distributed configuration 
management (with Spring Cloud Config), service-to-service communication 
(with Spring Cloud Feign or Spring Cloud WebClient), and distributed tracing 
(with Spring Cloud Sleuth).
Microservice Testing: Spring Boot offers testing support for microservices, 
including unit testing, integration testing, and end-to-end testing. It provides 
tools like Spring Boot Test, MockMvc, and TestRestTemplate to facilitate the 
testing of microservice components.
Spring Boot's extensive ecosystem and integration with Spring Cloud provide a 
solid foundation for building and deploying microservices. It promotes the 
development of modular, scalable, and resilient microservices architectures.
82. What is the purpose of the @Controller  annotation in Spring Boot?
The @Controller  annotation in Spring Boot is used to mark a class as a controller 
component in the MVC (Model-View-Controller) architecture. It is typically 
applied to classes that handle HTTP requests and define the endpoints for a 
web application.
By annotating a class with @Controller , you indicate to the Spring Boot 
framework that this class plays the role of a controller and should be responsible 
100+ Spring Boot Questions 52
for processing incoming requests, invoking appropriate methods, and returning 
responses.
Here's an example:
@Controller 
public class MyController { 
    @GetMapping("/hello") 
    public String sayHello() { 
        return "Hello, World!"; 
    } 
}
In this example, the MyController  class is annotated with @Controller , indicating that 
it is a controller component. The sayHello  method is annotated with @GetMapping  and 
defines a GET endpoint at /hello . When a request is made to /hello , this method is 
invoked, and the returned string "Hello, World!" is sent as the response.
The @Controller  annotation is a fundamental building block for creating web 
applications in Spring Boot, allowing you to define the behavior and handling of 
HTTP requests.
83. How can you handle validation errors in a Spring Boot application?
In a Spring Boot application, you can handle validation errors in several ways, 
depending on your requirements and preferences:
Using BindingResult : When performing server-side validation using 
annotations like @Valid , you can pass a BindingResult  object as a parameter 
to your controller method. The BindingResult  contains information about 
validation errors, allowing you to handle them accordingly.
Using @ExceptionHandler : You can define exception handling methods in your 
controllers using the @ExceptionHandler  annotation. By specifying the 
exception type, you can handle validation-related exceptions, such as 
MethodArgumentNotValidException  or BindException , and customize the response 
or error handling logic.
Using Global Exception Handling: You can use the @ControllerAdvice  
annotation to define global exception handling methods that apply to multiple 
controllers. By handling exceptions like MethodArgumentNotValidException  or 
BindException  at the global level, you can provide consistent error responses 
across your application.
100+ Spring Boot Questions 53
Using Custom Validation Errors: You can create custom validation error 
classes or objects that encapsulate validation errors specific to your 
application domain. By throwing and handling these custom errors, you can 
provide meaningful error messages and additional context to the client.
It's important to note that validation errors should be handled gracefully and 
provide appropriate error messages to the client. By employing these 
techniques, you can effectively handle validation errors and ensure the integrity 
of your application's data.
84. Explain the concept of a composite primary key in Spring Boot JPA.
In Spring Boot JPA (Java Persistence API), a composite primary key refers to a 
primary key that consists of multiple attributes or columns instead of a single 
attribute. It allows you to define a unique identifier for an entity based on multiple 
properties.
To define a composite primary key in Spring Boot JPA, you can use one of the 
following approaches:
Embedded Id: You can create an embeddable class annotated with 
@Embeddable  that represents the composite primary key fields. The entity 
class then includes an attribute of this embeddable class annotated with 
@EmbeddedId .
IdClass: You can create a separate class annotated with @IdClass  that holds 
the composite primary key fields. The entity class includes these fields as 
regular attributes and is annotated with @Id  and `@GeneratedValue`.
Here's an example using the @EmbeddedId  approach:
@Embeddable 
public class OrderItemId implements Serializable { 
    private Long orderId; 
    private Long productId; 
 
    // Getters, setters, constructors, and equals/hashCode methods 
} 
 
@Entity 
public class OrderItem { 
    @EmbeddedId 
    private OrderItemId id; 
 
    // Other attributes and relationships 
}
100+ Spring Boot Questions 54
In this example, the OrderItemId  class represents the composite primary key fields 
orderId  and productId . The OrderItem  entity includes an attribute id  of type 
OrderItemId  annotated with @EmbeddedId .
Composite primary keys are useful when the uniqueness of an entity cannot be 
determined by a single attribute and requires a combination of multiple attributes. 
They allow you to express complex relationships and ensure data integrity in your 
Spring Boot JPA entities.
85. What is the purpose of the @ConfigurationProperties  annotation in Spring 
Boot?
The @ConfigurationProperties  annotation in Spring Boot is used to bind external 
configuration properties to the fields of a Java class. It allows you to map 
properties from various sources, such as application.properties , application.yml , 
environment variables, or command-line arguments, to the fields of a 
configuration class.
By annotating a class with @ConfigurationProperties  and specifying a prefix, you 
establish a relationship between the properties and the class fields. Spring Boot 
automatically maps the properties with matching names to the corresponding 
fields.
Here's an example:
@Component 
@ConfigurationProperties(prefix = "myapp") 
public class MyAppProperties { 
    private String name; 
    private String version; 
 
    // Getters and setters 
}
In this example, the MyAppProperties  class is annotated with @ConfigurationProperties  
and the prefix myapp . The properties myapp.name  and myapp.version  from the 
configuration source (e.g., application.properties ) are automatically mapped to the 
name  and version  fields of the class.
The @ConfigurationProperties  annotation simplifies the process of external 
configuration in Spring Boot applications by providing type-safe binding of 
properties to Java objects. It helps centralize and organize configuration 
properties, making them more manageable and easier to change.
86. How does Spring Boot handle database transactions?
100+ Spring Boot Questions 55
Spring Boot provides support for database transactions through its integration 
with the Spring Framework's transaction management capabilities.
To handle database transactions in a Spring Boot application, you typically follow 
these steps:
1. Configure a transaction manager: Spring Boot supports various transaction 
managers, such as DataSourceTransactionManager  for JDBC-based 
transactions, JpaTransactionManager  for JPA-based transactions, or 
JtaTransactionManager  for distributed transactions. You can configure the 
appropriate transaction manager based on your data access technology.
2. Annotate transactional methods: In your service or repository classes, you 
can annotate the methods that participate in transactions with the 
@Transactional  annotation. This annotation marks the boundaries of the 
transaction and specifies the transactional behavior, such as propagation, 
isolation level, and rollback rules.
3. Handle exceptions and commit/rollback: Spring Boot's transaction 
management automatically handles the commit/rollback of database 
transactions based on the defined rules. If an exception occurs within a 
transactional method, Spring Boot rolls back the transaction by default, 
ensuring data consistency.
Here's an example:
@Service 
public class UserService { 
    @Autowired 
    private UserRepository userRepository; 
 
    @Transactional 
    public void createUser(User user) { 
        userRepository.save(user); 
        // Additional database operations 
    } 
} 
 
In this example, the createUser  method is annotated with @Transactional , indicating 
that it participates in a database transaction. Any database operations performed 
within this method, such as saving a user to the repository, will be part of the 
transaction.
100+ Spring Boot Questions 56
By leveraging Spring Boot's transaction management capabilities, you can 
ensure data integrity, consistency, and ACID (Atomicity, Consistency, Isolation, 
Durability) properties for your database operations.
87. What is the purpose of the @Valid  annotation in Spring Boot?
The @Valid  annotation in Spring Boot is used to trigger validation of a bean or 
method parameter.
When you apply the @Valid  annotation to a parameter or field, Spring Boot 
automatically performs validation based on the validation constraints specified 
on that parameter or field.
Here's an example:
@RestController 
public class UserController { 
    @PostMapping("/users") 
    public ResponseEntity<String> createUser(@Valid @RequestBody User user) { 
        // Logic to create a user 
        // ... 
    } 
}
In this example, the createUser  method is annotated with @PostMapping  and defines a 
POST endpoint for creating a user. The @Valid  annotation is applied to the user  
parameter, indicating that the User  object received in the request body should be 
validated based on its validation constraints.
By using the @Valid  annotation, Spring Boot triggers the validation process and 
checks the validity of the User  object. If any validation errors occur, they are 
automatically handled, and a validation error response is returned.
The @Valid  annotation allows you to ensure the validity of input data and enforce 
validation constraints, promoting data integrity and preventing the processing of 
invalid or malformed data.
88. How can you configure a thread pool in Spring Boot?
In Spring Boot, you can configure a thread pool by customizing the 
ThreadPoolTaskExecutor  bean. The ThreadPoolTaskExecutor  is a class provided by 
the Spring Framework that allows you to manage and control a thread pool.
To configure a thread pool in Spring Boot, you can follow these steps:
100+ Spring Boot Questions 57
1. Create a configuration class and annotate it with @Configuration .
2. Define a method that returns a ThreadPoolTaskExecutor  bean.
3. Customize the properties of the ThreadPoolTaskExecutor  bean, such as the 
core pool size, maximum pool size, queue capacity, thread names, etc.
Here's an example:
import org.springframework.context.annotation.Bean; 
import org.springframework.context.annotation.Configuration; 
import org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor; 
 
@Configuration 
public class ThreadPoolConfig { 
    @Bean 
    public ThreadPoolTaskExecutor taskExecutor() { 
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor(); 
        executor.setCorePoolSize(10); 
        executor.setMaxPoolSize(20); 
        executor.setQueueCapacity(100); 
        executor.setThreadNamePrefix("MyThread-"); 
        executor.initialize(); 
        return executor; 
    } 
} 
In this example, the taskExecutor  method configures a ThreadPoolTaskExecutor  bean 
with a core pool size of 10, a maximum pool size of 20, a queue capacity of 100, and 
a thread name prefix of "MyThread-". The initialize()  method initializes the 
executor with the provided configuration.
Once the ThreadPoolTaskExecutor  bean is configured, you can inject it into your 
components and use it for concurrent or asynchronous tasks.
89. Explain the concept of conditional bean creation in Spring Boot.
Conditional bean creation in Spring Boot allows you to conditionally create and 
configure beans based on certain conditions or criteria. It helps you control the 
creation of beans dynamically, depending on the environment, configuration, or 
other factors.
Spring Boot provides the @Conditional  annotation and several built-in conditional 
annotations that you can use to control bean creation. These annotations 
include:
@ConditionalOnClass : Creates a bean only if the specified class is present in 
the classpath.
100+ Spring Boot Questions 58
@ConditionalOnMissingClass : Creates a bean only if the specified class is not 
present in the classpath.
@ConditionalOnBean : Creates a bean only if the specified bean is present in 
the application context.
@ConditionalOnMissingBean : Creates a bean only if the specified bean is not 
present in the application context.
@ConditionalOnProperty : Creates a bean based on the value of a configuration 
property.
@ConditionalOnExpression : Creates a bean based on the evaluation of a SpEL 
(Spring Expression Language) expression.
@ConditionalOnWebApplication : Creates a bean only if the application is a web 
application.
@ConditionalOnNotWebApplication : Creates a bean only if the application is not a 
web application.
By using these conditional annotations, you can fine-tune the creation and 
configuration of beans in your Spring Boot application based on the desired 
conditions. It allows you to create flexible and adaptive bean configurations, 
optimizing the usage of resources and adapting to different runtime 
environments.
90. What is the purpose of the @ModelAttribute  annotation in Spring Boot?
The @ModelAttribute  annotation in Spring Boot is used to bind request data to 
method parameters or model attributes in a controller method.
When a controller method is annotated with @ModelAttribute , Spring Boot 
automatically binds request parameters or attributes to the method parameters 
or model attributes based on their names.
Here's an example:
@Controller 
public class UserController { 
    @GetMapping("/users/{id}") 
    public String getUser(@PathVariable Long id, @ModelAttribute("message") String mes
sage, Model model) { 
        User user = userService.getUserById(id); 
        model.addAttribute("user", user); 
        return "user"; 
    } 
} 
100+ Spring Boot Questions 59
In this example, the getUser  method is annotated with @GetMapping  and handles the 
GET request for retrieving a user. The @ModelAttribute("message")  annotation binds 
the request parameter or attribute with the name "message" to the method 
parameter message .
The @ModelAttribute  annotation can also be used at the method level to specify 
model attributes that are shared by multiple handler methods within the same 
controller.
By using the @ModelAttribute  annotation, you can conveniently bind request data 
to method parameters or model attributes, making them available for further 
processing or rendering in views.
91. How does Spring Boot handle content negotiation?
Content negotiation in Spring Boot refers to the process of determining the 
representation format (e.g., JSON, XML, HTML) to be returned based on the 
client's requested media types.
Spring Boot provides built-in support for content negotiation through the 
following mechanisms:
@RequestMapping  and Media Types: In Spring Boot, you can use the 
@RequestMapping  annotation along with the produces  attribute to specify the 
media types that the controller method can produce. The client's requested 
media types are compared with the produces  attribute, and the appropriate 
representation format is returned.
ContentNegotiationConfigurer : Spring Boot allows you to configure content 
negotiation globally by customizing the ContentNegotiationConfigurer  bean. 
You can specify default media types, media type strategies, and content 
negotiation rules.
ContentNegotiationManager : The ContentNegotiationManager  interface provides 
more fine-grained control over content negotiation. You can create and 
configure an instance of ContentNegotiationManager  to define media type 
mappings, parameter-based content negotiation, or content negotiation 
based on the request headers.
Spring Boot supports various content negotiation strategies, such as using file 
extensions (e.g., .json , .xml ) or request headers ( Accept  header) to determine 
the client's preferred representation format.
100+ Spring Boot Questions 60
By default, Spring Boot uses the MappingJackson2HttpMessageConverter  to handle 
JSON content negotiation and the StringHttpMessageConverter  for other media 
types. However, you can customize and configure additional message 
converters based on your specific requirements.
Through these mechanisms, Spring Boot enables flexible content negotiation 
and provides support for serving different representation formats to clients based 
on their preferences.
92. What is the purpose of the @EnableCaching  annotation in Spring Boot?
The @EnableCaching  annotation in Spring Boot is used to enable caching 
capabilities in a Spring Boot application.
By annotating a configuration class with @EnableCaching , Spring Boot enables the 
caching infrastructure and activates the caching features provided by the 
underlying caching framework, such as Ehcache, Redis, or Caffeine.
Here's an example:
@Configuration 
@EnableCaching 
public class CachingConfig { 
    // Cache-related configuration 
}
In this example, the CachingConfig  class is annotated with @EnableCaching , indicating 
that caching is enabled for the application. You can also include additional cache-
related configuration within this class.
After enabling caching, you can apply caching annotations, such as @Cacheable , 
@CachePut , or @CacheEvict , on methods that are candidates for
caching. These annotations allow you to define caching behavior and specify 
cache names or keys.
Caching in Spring Boot helps improve application performance by caching the 
results of expensive or time-consuming operations. It reduces the load on 
backend systems and improves response times for frequently accessed data.
93. How can you enable compression in a Spring Boot application?
Spring Boot provides built-in support for enabling compression of HTTP 
responses, which reduces the response size and improves network efficiency.
To enable compression in a Spring Boot application, you can follow these steps:
100+ Spring Boot Questions 61
1. Include the appropriate compression libraries in your project's 
dependencies. For example, you can include the io.springfox:springfox-
compression  dependency for compression support with Swagger.
2. Configure compression properties in your application's configuration file 
( application.properties  or application.yml ). Set the properties 
server.compression.enabled  to true  and configure additional compression-
related properties, such as server.compression.mime-types  to specify the MIME 
types to be compressed.
3. Customize the compression settings by creating a WebServerFactoryCustomizer  
bean. You can define the compression algorithm, compression level, and 
other compression-related properties.
Here's an example using application.properties :
server.compression.enabled=true 
server.compression.mime-types=application/json,application/xml 
By enabling compression in your Spring Boot application, the server automatically 
compresses the HTTP responses for the specified MIME types, reducing the 
response size and improving network performance.
It's important to note that compression should be used judiciously, considering 
factors such as the response size, the client's capabilities, and the network 
conditions.
94. Explain the concept of AOP (Aspect-Oriented Programming) in Spring 
Boot.
Aspect-Oriented Programming (AOP) is a programming paradigm that aims to 
separate cross-cutting concerns from the core business logic of an application. It 
provides a modular approach to address common functionalities that span 
across multiple components or layers, such as logging, caching, security, and 
transaction management.
In Spring Boot, AOP is implemented using the Spring Framework's AOP module, 
which leverages proxy-based or bytecode manipulation techniques to achieve 
the aspect-oriented programming paradigm.
AOP introduces the concept of aspects, which are modules that encapsulate 
cross-cutting concerns. Aspects define advice, pointcuts, and join points:
100+ Spring Boot Questions 62
Advice: Advice represents the actual functionality or behavior to be applied 
at a particular join point in the application. It defines what actions to perform 
before, after, or around a join point.
Pointcut: Pointcut specifies the join points where the advice should be 
applied. It defines the criteria or conditions to match specific join points in the 
application, such as method invocations, method executions, or specific 
annotations.
Join Point: Join points are specific points in the application's execution flow, 
such as method invocations or field access. They represent the points in the 
application where advice can be applied.
Spring Boot provides various annotations, such as @Before , @After , @Around , 
and @AfterReturning , to define advice methods. By using these annotations and 
pointcut expressions, you can declaratively apply cross-cutting concerns to your 
application.
AOP in Spring Boot allows you to modularize cross-cutting concerns, reduce 
code duplication, improve code maintainability, and separate concerns that are 
not directly related to the core business logic. It enables you to focus on the 
essential functionality of your application while keeping cross-cutting concerns 
separate and reusable.
95. What is the purpose of the @ControllerAdvice  annotation in Spring Boot?
The @ControllerAdvice  annotation in Spring Boot is used to define global 
exception handling and apply it across multiple controllers.
By annotating a class with @ControllerAdvice , you can define methods that 
handle exceptions thrown by controller methods within the same or related 
controllers. These exception handling methods can handle specific exceptions or 
a general base exception, providing a central place for exception handling and 
error response generation.
The @ControllerAdvice  class typically includes methods annotated with 
@ExceptionHandler , which handle specific exception types, and can also include 
other advices, such as @InitBinder  methods for request data binding 
customization or @ModelAttribute  methods for adding model attributes across 
multiple controllers.
Here's an example:
100+ Spring Boot Questions 63
@ControllerAdvice 
public class GlobalExceptionHandler { 
    @ExceptionHandler(UserNotFoundException.class) 
    public ResponseEntity<String> handleUserNotFoundException(UserNotFoundException e
x) { 
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage()); 
    } 
 
    @ExceptionHandler(Exception.class) 
    public ResponseEntity<String> handleException(Exception ex) { 
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Internal
 Server Error"); 
    } 
}
In this example, the GlobalExceptionHandler  class is annotated with @ControllerAdvice , 
indicating that it provides global exception handling. It includes two exception 
handling methods: handleUserNotFoundException , which handles the 
UserNotFoundException , and handleException , which handles all other exceptions. 
These methods customize the error response based on the handled exceptions.
The @ControllerAdvice  annotation is a powerful mechanism in Spring Boot for 
defining consistent exception handling and error responses across multiple 
controllers. It helps centralize exception handling logic, improves code 
maintainability, and provides a unified approach to error handling in your 
application.
96. How does Spring Boot support the creation of GraphQL APIs?
Spring Boot provides support for building GraphQL APIs through the integration 
with libraries such as graphql-java  and graphql-spring-boot-starter .
To create a GraphQL API in Spring Boot, you can follow these steps:
1. Include the graphql-spring-boot-starter  dependency in your project. This 
dependency provides the necessary Spring Boot integration for GraphQL.
2. Define your GraphQL schema using the GraphQL schema definition 
language (SDL) or programmatically using Java classes.
3. Implement resolvers that define the logic for resolving GraphQL queries, 
mutations, and subscriptions.
4. Annotate your resolvers with the @Component  annotation or use the @Bean  
annotation to register them as Spring beans.
100+ Spring Boot Questions 64
5. Optionally, customize the GraphQL endpoint URL or enable GraphQL 
Playground for interactive exploration and testing.
Here's an example of a simple GraphQL schema and resolver in Spring Boot:
@Component 
public class HelloWorldResolver implements GraphQLQueryResolver { 
    public String hello() { 
        return "Hello, World!"; 
    } 
}
In this example, the HelloWorldResolver  class is annotated with @Component  and 
implements the GraphQLQueryResolver  interface. The hello()  method serves as a 
resolver for the "hello" query, returning the "Hello, World!" string.
With this setup, you can start your Spring Boot application and access the 
GraphQL endpoint to execute queries against the defined schema.
Spring Boot's integration with GraphQL provides a convenient way to build 
GraphQL APIs, leveraging the power of GraphQL's type system, introspection, 
and query flexibility while benefiting from Spring Boot's ease of development, 
dependency management, and ecosystem integration.
97. What is the purpose of the @ResponseStatus  annotation in Spring Boot?
The @ResponseStatus  annotation in Spring Boot is used to declare the HTTP 
response status code that should be returned by a controller method.
By annotating a controller method with @ResponseStatus , you can explicitly specify 
the HTTP status code to be sent as part of the response when that method is 
invoked.
Here's an example:
@RestController 
public class UserController { 
    @GetMapping("/users/{id}") 
    @ResponseStatus(HttpStatus.OK) 
    public User getUser(@PathVariable Long id) { 
        // Logic to retrieve and return the user 
    } 
} 
In this example, the getUser  method is annotated with @GetMapping  to handle a GET 
request for retrieving a user. The @ResponseStatus(HttpStatus.OK)  annotation is applied 
100+ Spring Boot Questions 65
to indicate that the response should have an HTTP status code of 200 (OK).
The @ResponseStatus  annotation allows you to provide a clear and explicit 
declaration of the intended HTTP response status for a controller method. It 
enhances the readability and self-documentation of your code, making it easier to 
understand the expected response status for each endpoint.
98. How can you configure a custom exception handler in Spring Boot?
In Spring Boot, you can configure a custom exception handler by creating a 
class that implements the HandlerExceptionResolver  interface or by using the 
@ExceptionHandler  annotation.
Here's an example of creating a custom exception handler by implementing 
HandlerExceptionResolver :
@Component 
public class CustomExceptionHandler implements HandlerExceptionResolver { 
    @Override 
    public ModelAndView resolveException(HttpServletRequest request, HttpServletRespon
se response, Object handler, Exception ex) { 
        // Custom exception handling logic 
        ModelAndView modelAndView = new ModelAndView(); 
        modelAndView.setViewName("error"); 
        modelAndView.addObject("message", "An error occurred"); 
        return modelAndView; 
    } 
} 
In this example, the CustomExceptionHandler  class implements the 
HandlerExceptionResolver  interface. The resolveException  method is responsible for 
handling exceptions and returning an appropriate ModelAndView  object.
Alternatively, you can use the @ExceptionHandler  annotation to define exception 
handling methods within your controller classes:
@Controller 
public class UserController { 
    @ExceptionHandler(UserNotFoundException.class) 
    public ResponseEntity<String> handleUserNotFoundException(UserNotFoundException e
x) { 
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(ex.getMessage()); 
    } 
} 
In this example, the handleUserNotFoundException  method is annotated with 
@ExceptionHandler  and handles the UserNotFoundException . It customizes the error 
100+ Spring Boot Questions 66
response based on the handled exception.
Both approaches allow you to define custom exception handling logic in your 
Spring Boot application. You can choose the approach that best fits your 
requirements and preference.
99. What is Spring Boot?
Spring Boot is an open-source framework built on top of the Spring Framework 
that simplifies the development of Java applications. It provides a convention-
over-configuration approach, along with opinionated defaults and auto-
configuration capabilities, to streamline application setup and development.
Spring Boot aims to make it easier to create standalone, production-grade 
Spring-based applications with minimal effort. It eliminates the need for manual 
configuration and boilerplate code by leveraging sensible defaults and intelligent 
auto-configuration based on classpath scanning and the presence of certain 
dependencies.
With Spring Boot, developers can quickly create Spring applications that are 
self-contained, standalone, and ready to be deployed with minimal setup and 
configuration.
00. What are the advantages of using Spring Boot?
Spring Boot offers several advantages that make it a popular choice for 
developing Java applications:
Simplified Setup and Configuration: Spring Boot eliminates the need for 
manual configuration by providing sensible defaults and auto-configuration. 
It reduces the setup time and effort required to start a new project.
Opinionated Defaults: Spring Boot follows best practices and provides 
opinionated defaults for various components, such as embedded servers, 
logging frameworks, and database access. These defaults work well in most 
cases, reducing the need for manual configuration.
Auto-Configuration: Spring Boot automatically configures components 
based on the dependencies present in the classpath. It leverages classpath 
scanning and conditionals to detect and configure components, reducing the 
need for explicit configuration.
100+ Spring Boot Questions 67
Embedded Servers: Spring Boot includes embedded servers, such as 
Tomcat, Jetty, or Undertow, allowing you to run applications as standalone 
JAR files without the need for deploying to a separate server.
Dependency Management: Spring Boot simplifies dependency 
management by providing a curated set of dependencies and their 
compatible versions. It helps manage version conflicts and ensures the 
compatibility of the dependencies used in your project.
Actuator: Spring Boot Actuator provides production-ready features, such as 
health checks, metrics, monitoring, and management endpoints, out of the 
box. It allows you to monitor and manage your application easily.
Developer Productivity: Spring Boot's simplicity and convention-over-
configuration approach boost developer productivity. It reduces boilerplate 
code, provides a consistent programming model, and offers powerful 
development tools and features.
Overall, Spring Boot enables developers to focus on building business logic 
rather than dealing with infrastructure and configuration concerns. It promotes 
rapid application development, improves maintainability, and enhances the 
scalability and robustness of Spring-based applications.
